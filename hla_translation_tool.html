<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Half-Life: Alyx Translation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #242424;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #333;
        }

        .sidebar-header h2 {
            font-size: 18px;
            font-weight: 500;
            color: #ff6b1a;
        }

        .project-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
		
		/* Debug column styling */
td:nth-child(9) {
    max-width: 200px;
    font-size: 11px;
    color: #666;
    word-break: break-all;
    line-height: 1.2;
}

th:nth-child(9) {
    max-width: 200px;
    font-size: 12px;
}

/* =========================== PROJECT COMPLETE STYLE START =========================== */
.project-item.completed {
    border: 3px solid #4caf50;
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
}
/* =========================== PROJECT COMPLETE STYLE END =========================== */


.project-item {
    padding: 12px 15px;
    margin: 5px 0;
    background: #2a2a2a;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    user-select: none;
    min-height: 60px; /* Mehr Platz für Statistiken */
}

        .project-item:hover {
            cursor: grab;
        }

        .project-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 5px 15px rgba(255, 107, 26, 0.3);
        }

        .project-item.drag-over {
            border-top: 3px solid #ff6b1a;
            margin-top: 8px;
        }

        .project-item:hover {
            background: #333;
        }

        .project-item.active {
            background: #ff6b1a;
            color: #fff;
        }

        .project-item .delete-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            padding: 5px;
            opacity: 0;
            transition: opacity 0.2s;
            border-radius: 3px;
        }

        .project-item .project-customize-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            padding: 5px;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            border-radius: 3px;
        }

        .project-item:hover .delete-btn,
        .project-item:hover .project-customize-btn {
            opacity: 1;
        }

        .project-item .delete-btn:hover {
            color: #ff4444;
            background: rgba(255,68,68,0.2);
        }

        .project-item .project-customize-btn:hover {
            color: #ff6b1a;
            background: rgba(255,107,26,0.2);
        }

        .add-project-btn {
            margin: 10px;
            padding: 12px;
            background: #ff6b1a;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }

        .add-project-btn:hover {
            background: #ff8c47;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            background: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-container {
            flex: 1;
            max-width: 400px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #ff6b1a;
        }
			

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            margin-top: 5px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
		
		

        .search-result-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: #333;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-filename {
            font-weight: 500;
            color: #ff6b1a;
        }

        .search-result-path {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        .search-result-text {
            font-size: 12px;
            color: #999;
            margin-top: 3px;
        }

        .search-result-match {
            background: #ff6b1a;
            color: #000;
            padding: 1px 3px;
            border-radius: 2px;
        }

        .search-result-similarity {
            color: #4caf50;
            font-size: 11px;
            float: right;
        }

        /* Table Controls */
        .table-controls {
            background: #242424;
            padding: 10px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sort-btn {
            padding: 6px 12px;
            background: #444;
            border: none;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .sort-btn:hover {
            background: #555;
        }

        .sort-btn.active {
            background: #ff6b1a;
            color: white;
        }

        .progress-info {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 13px;
        }

        .progress-stat {
            padding: 4px 8px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .progress-stat.good {
            border-color: #4caf50;
            color: #4caf50;
        }

        .progress-stat.warning {
            border-color: #ff9800;
            color: #ff9800;
        }

        .add-files-container {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .file-input {
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            width: 200px;
            min-height: 36px;
            resize: vertical;
        }

        .btn {
            padding: 10px 20px;
            background: #ff6b1a;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #ff8c47;
        }

        .btn-secondary {
            background: #444;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .btn-danger {
            background: #d32f2f;
        }

        .btn-danger:hover {
            background: #f44336;
        }

        .btn-success {
            background: #4caf50;
        }

        .btn-success:hover {
            background: #66bb6a;
        }

        /* File Browser */
        .file-browser-btn {
            padding: 8px 16px;
            background: #444;
            border: none;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .file-browser-btn:hover {
            background: #555;
        }

        /* Table */
        .table-container {
            flex: 1;
            overflow: auto;
            background: #1a1a1a;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }

        th {
            background: #2a2a2a;
            padding: 15px 10px;
            text-align: left;
            font-weight: 500;
            color: #ff6b1a;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 2px solid #444;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #333;
        }

        th.sortable::after {
            content: ' ↕';
            opacity: 0.5;
            font-size: 12px;
        }

        th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
            color: #ff6b1a;
        }

        th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
            color: #ff6b1a;
        }

        td {
            padding: 12px 10px;
            border-bottom: 1px solid #333;
            vertical-align: top;
        }

        tr:hover {
            background: #242424;
        }

        tr.duplicate-warning {
            background: #3d2f00;
        }

        tr.completed {
            background: rgba(76, 175, 80, 0.1);
        }

        tr.selected-row {
            background: rgba(255, 107, 26, 0.1) !important;
            border: 1px solid rgba(255, 107, 26, 0.3);
        }

        .draggable {
            cursor: move;
        }

        .dragging {
            opacity: 0.5;
        }

        .drag-over {
            background: #333 !important;
        }

        .text-input {
            width: 100%;
            padding: 8px 10px;
            background: #242424;
            border: 1px solid #333;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            transition: border-color 0.2s;
            min-height: 36px;
            resize: none;
            overflow: hidden;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .text-input:focus {
            outline: none;
            border-color: #ff6b1a;
            background: #2a2a2a;
        }

        /* Fixed width text columns */
        td:nth-child(7), td:nth-child(8) {
            width: 25%;
            min-width: 200px;
            vertical-align: top;
        }

        th:nth-child(7), th:nth-child(8) {
            width: 25%;
            min-width: 200px;
        }

/* Make table responsive - aktualisierte Spalten-Nummern */
@media (max-width: 1200px) {
    td:nth-child(7), td:nth-child(8) {
        width: 25%;
        min-width: 180px;
    }
    th:nth-child(7), th:nth-child(8) {
        width: 25%;
        min-width: 180px;
    }
    /* Debug-Spalte bei kleinen Bildschirmen ausblenden */
    td:nth-child(9), th:nth-child(9) {
        display: none;
    }
}

@media (max-width: 900px) {
    td:nth-child(7), td:nth-child(8) {
        width: 30%;
        min-width: 160px;
    }
    th:nth-child(7), th:nth-child(8) {
        width: 30%;
        min-width: 160px;
    }
    td:nth-child(9), th:nth-child(9) {
        display: none;
    }
}

        .play-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }

        .play-btn:hover {
            background: #ff6b1a;
            color: white;
        }

        .play-btn.playing {
            background: #ff6b1a;
            color: white;
            animation: pulse 1s infinite;
        }

        .de-play-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }

        .de-play-btn.playing,
        .de-play-btn:hover {
            background: #2e7d32;
            color: white;
        }

        .upload-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }

        .upload-btn:hover {
            background: #1976d2;
            color: white;
        }

        .delete-row-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 18px;
        }

        .delete-row-btn:hover {
            background: #ff4444;
            color: white;
        }

        .copy-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 4px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .copy-btn:hover {
            background: #ff6b1a;
            color: white;
            transform: scale(1.1);
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .completion-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .folder-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .folder-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px 0;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            min-width: 180px;
            display: none;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 14px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: #333;
        }

        .context-menu-item.danger:hover {
            background: #d32f2f;
        }

        .context-menu-divider {
            height: 1px;
            background: #444;
            margin: 5px 0;
        }

        /* Import/Export Dialog */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .dialog {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .dialog h3 {
            color: #ff6b1a;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .dialog textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        /* Status Bar */
        .status-bar {
            background: #1a1a1a;
            border-top: 1px solid #333;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #999;
        }

        .status-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .access-status {
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            border: 1px solid transparent;
        }

        .access-status:hover {
            background: #333;
            transform: scale(1.05);
        }

        .access-status.good {
            color: #4caf50;
            border-color: #4caf50;
        }

        .access-status.warning {
            color: #ff9800;
            border-color: #ff9800;
            animation: pulse-warning 2s infinite;
        }

        .access-status.error {
            color: #f44336;
            border-color: #f44336;
            animation: pulse-error 2s infinite;
        }

        .access-status.none {
            color: #666;
            border-color: #666;
        }

        .save-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes pulse-error {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulse-auto-scan {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.05);
            }
        }

        /* Drag handle */
        .drag-handle {
            cursor: move;
            color: #666;
            padding: 0 10px;
            font-size: 20px;
        }

        .drag-handle:hover {
            color: #ff6b1a;
        }

        .row-number {
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            color: #ccc;
            font-weight: 500;
        }

        .row-number:hover {
            color: #ff6b1a;
            background: rgba(255, 107, 26, 0.1);
            border-radius: 4px;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .empty-state p {
            font-size: 16px;
        }

        /* Audio player */
        #audioPlayer {
            display: none;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* File scan progress */
        .scan-progress {
            display: none;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            margin: 20px;
        }

        .scan-progress.active {
            display: block;
        }

        .progress-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: #ff6b1a;
            width: 0%;
            transition: width 0.3s;
        }

        .scan-status {
            font-size: 14px;
            color: #999;
        }

        /* Export progress */
        .export-progress {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .export-status {
            font-size: 14px;
            color: #999;
            margin-bottom: 10px;
        }

        .file-list {
            max-height: 300px;
            overflow-y: auto;
            background: #242424;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .file-list-item {
            padding: 5px 0;
            font-size: 12px;
            color: #999;
            border-bottom: 1px solid #333;
        }

        .file-list-item:last-child {
            border-bottom: none;
        }

        .file-list-item.success {
            color: #4caf50;
        }

        .file-list-item.error {
            color: #f44336;
        }

        /* ZIP Download Button */
        .download-section {
            background: #242424;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .download-info {
            color: #999;
            margin-bottom: 15px;
        }

        .download-btn {
            padding: 12px 30px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .download-btn:hover {
            background: #66bb6a;
        }

        .download-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

/* =========================== DIALOG CLOSE BTN STYLE START =========================== */
.folder-browser-dialog .dialog { position:relative; }

.dialog-close-btn{
    position:absolute;
    top:12px;
    right:12px;
    background:transparent;
    border:none;
    color:#e0e0e0;
    font-size:24px;
    line-height:1;
    cursor:pointer;
    transition:color .2s, transform .2s;
}
.dialog-close-btn:hover{
    color:#ff6b1a;
    transform:scale(1.2);
}
/* =========================== DIALOG CLOSE BTN STYLE END =========================== */

/* =========================== LEVEL-STATS PANEL STYLE START =========================== */
.level-stats{
    background:#1a1a1a;
    border:1px solid #444;
    border-radius:6px;
    padding:10px 15px;
    margin-top:20px;
}
.level-stats summary{
    cursor:pointer;
    font-weight:600;
    color:#ff6b1a;
    outline:none;
}
.level-stats table{
    width:100%;
    border-collapse:collapse;
    margin-top:12px;
    font-size:13px;
}
.level-stats th,
.level-stats td{
    padding:6px 8px;
    border-bottom:1px solid #333;
}
.level-stats th{ text-align:left; }
.level-stats tr:last-child td{ border-bottom:none; }
/* =========================== LEVEL-STATS PANEL STYLE END =========================== */


        .folder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .folder-card {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .folder-card:hover {
            background: #242424;
            border-color: #ff6b1a;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 26, 0.2);
        }

        .folder-card-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .folder-card-name {
            font-weight: 500;
            color: #ff6b1a;
            margin-bottom: 5px;
        }

        .folder-card-count {
            color: #999;
            font-size: 12px;
        }

        .folder-files-view {
            display: none;
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
            border: 1px solid #444;
            border-radius: 6px;
        }

        .folder-file-item {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .folder-file-item:last-child {
            border-bottom: none;
        }

        .folder-file-item:hover {
            background: #242424;
        }

        .folder-file-info {
            flex: 1;
            min-width: 0;
        }

        .folder-file-name {
            font-weight: 500;
            color: #ff6b1a;
            margin-bottom: 4px;
        }

        .folder-file-texts {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .folder-file-text {
            flex: 1;
            min-width: 0;
        }

        .folder-file-text-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .folder-file-text-content {
            font-size: 13px;
            color: #ccc;
            background: #242424;
            padding: 6px 8px;
            border-radius: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-file-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .folder-file-play {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .folder-file-play:hover {
            background: #ff6b1a;
            color: white;
        }

        .folder-file-add {
            background: #4caf50;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .folder-file-add:hover {
            background: #66bb6a;
        }

        .folder-file-add:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .folder-back-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: background 0.2s;
        }

        .folder-back-btn:hover {
            background: #555;
        }

        /* Folder customization */
        .folder-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .folder-customize-btn {
            background: #444;
            border: none;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .folder-customize-btn:hover {
            background: #ff6b1a;
        }

        .folder-customize-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            z-index: 3000;
            min-width: 300px;
        }

        .folder-customize-popup h4 {
            color: #ff6b1a;
            margin-bottom: 15px;
        }

        .customize-field {
            margin-bottom: 15px;
        }

        .customize-field label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 14px;
        }

        .customize-field input, .customize-field select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .icon-preview {
            display: inline-block;
            font-size: 24px;
            margin-left: 10px;
            padding: 5px;
            border-radius: 4px;
            background: #1a1a1a;
            border: 1px solid #444;
        }

        .color-preview {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            margin-left: 10px;
            border: 1px solid #444;
            vertical-align: middle;
        }

        .customize-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .folder-card.completed {
            border: 3px solid #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .folder-card-completion {
            margin-top: 8px;
            font-size: 11px;
            font-weight: bold;
        }

        .folder-card-completion.complete {
            color: #4caf50;
        }

        .folder-card-completion.partial {
            color: #ff9800;
        }

        .folder-card-completion.none {
            color: #666;
        }

        .folder-file-item.completed {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid #4caf50;
        }

        .folder-file-completed-badge {
            background: #4caf50;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 10px;
        }

        .folder-stats {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }

        .folder-stats h4 {
            color: #ff6b1a;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .folder-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .folder-stat-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .folder-stat-number {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .folder-stat-number.complete {
            color: #4caf50;
        }

        .folder-stat-number.partial {
            color: #ff9800;
        }

        .folder-stat-number.none {
            color: #666;
        }

        .folder-stat-label {
            font-size: 12px;
            color: #999;
        }

        .cleanup-progress {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .cleanup-status {
            font-size: 14px;
            color: #999;
            margin-bottom: 10px;
        }

        .duplicate-group {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }

        .duplicate-group-header {
            color: #ff6b1a;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .duplicate-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .duplicate-item.keep {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .duplicate-item.delete {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .duplicate-item-info {
            flex: 1;
        }

        .duplicate-item-score {
            background: #333;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 10px;
        }

        .duplicate-item-score.high {
            background: #4caf50;
        }

        .duplicate-item-score.medium {
            background: #ff9800;
        }

        .duplicate-item-score.low {
            background: #f44336;
        }

        .customize-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2500;
        }
		
/* =========================== PROJECT META STYLE START =========================== */
.project-meta-bar{
    background:#242424;
    padding:10px 20px;
    border-bottom:1px solid #333;
    display:flex;
    align-items:center;
    gap:18px;
    font-size:14px;
}
.meta-project{font-size:18px;font-weight:600;color:#fff;}
.meta-label{color:#888;}
.project-meta-bar span:not(.meta-project){color:#ff6b1a;font-weight:500;}

.copy-level-btn{
    background:#444;
    border:none;
    color:#e0e0e0;
    padding:5px 9px;
    border-radius:4px;
    font-size:15px;
    cursor:pointer;
    transition:background .2s;
}
.copy-level-btn:hover{background:#ff6b1a;color:#fff;}
/* =========================== PROJECT META STYLE END =========================== */

/* =========================== PROJECT LEVEL BADGE STYLE START =========================== */
.level-part-badge{
    position:absolute;
    top:6px;
    right:10px;
    font-size:22px;
    font-weight:700;
    line-height:1;
    color:#ffffff;
    opacity:0.85;
    pointer-events:none;
    text-shadow:0 0 4px rgba(0,0,0,0.6);
}
/* =========================== PROJECT LEVEL BADGE STYLE END =========================== */

/* File Exchange Dialog Styling */
.file-exchange-dialog {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.file-exchange-content {
    background: #2a2a2a;
    border-radius: 8px;
    padding: 30px;
    max-width: 800px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
}

.file-exchange-content h3 {
    color: #ff6b1a;
    margin-bottom: 20px;
    font-size: 20px;
}

.current-file-info {
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 20px;
}

.current-file-info h4 {
    color: #4caf50;
    margin-bottom: 10px;
}

.similar-entries-list {
    max-height: 400px;
    overflow-y: auto;
}

.similar-entry-item {
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
}

.similar-entry-item:hover {
    background: #333;
    border-color: #ff6b1a;
}

.similar-entry-item.selected {
    background: #ff6b1a;
    color: #fff;
    border-color: #ff6b1a;
}

.similarity-score {
    position: absolute;
    top: 10px;
    right: 15px;
    background: #4caf50;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: bold;
}

.similarity-score.high {
    background: #4caf50;
}

.similarity-score.medium {
    background: #ff9800;
}

.similarity-score.low {
    background: #f44336;
}

.entry-filename {
    font-weight: bold;
    color: #ff6b1a;
    margin-bottom: 5px;
}

.entry-folder {
    font-size: 12px;
    color: #666;
    margin-bottom: 10px;
}

.entry-text {
    font-size: 13px;
    line-height: 1.4;
    background: #242424;
    padding: 8px;
    border-radius: 4px;
    margin: 5px 0;
}

.entry-text.en {
    border-left: 3px solid #2196f3;
}

.entry-text.de {
    border-left: 3px solid #ff9800;
}

.exchange-preview {
    background: #1a3a1a;
    border: 1px solid #4caf50;
    border-radius: 6px;
    padding: 15px;
    margin: 20px 0;
    display: none;
}

.exchange-preview h4 {
    color: #4caf50;
    margin-bottom: 10px;
}

.exchange-changes {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.change-item {
    background: #242424;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
}

.change-item.old {
    border-left: 3px solid #f44336;
}

.change-item.new {
    border-left: 3px solid #4caf50;
}

.folder-badge.clickable {
    cursor: pointer;
    transition: all 0.2s;
}

.folder-badge.clickable:hover {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(255, 107, 26, 0.3);
    filter: brightness(1.2);
}

		
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>🎮 Projekte</h2>
            </div>
            <div class="project-list" id="projectList"></div>
            <button class="add-project-btn" onclick="addProject()">+ Neues Projekt</button>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="search-container">
                    <input type="text" class="search-input" placeholder="Live-Suche: Dateiname oder Text... (Groß-/Kleinschreibung, Punkte ignoriert)" id="searchInput">
                    <div class="search-results" id="searchResults"></div>
                </div>
                
                <div class="add-files-container">
                    <textarea class="file-input" placeholder="Dateinamen eingeben (einer pro Zeile)..." id="fileInput" rows="1"></textarea>
                    <button class="btn" onclick="addFiles()">Hinzufügen</button>
                    <input type="file" id="folderPicker" webkitdirectory multiple style="display: none;" onchange="scanFolder(this)">
                    <button class="btn btn-secondary" onclick="waehleProjektOrdner()">📂 Projektordner wählen</button>
                </div>

                <button class="btn btn-secondary" onclick="showImportDialog()">📥 Import</button>
                <button class="btn btn-secondary" onclick="showFolderBrowser()">📁 Ordner durchsuchen</button>
                <button class="btn btn-secondary" onclick="cleanupDuplicates()">🧹 Duplikate bereinigen</button>
                <button class="btn btn-success" onclick="showExportDialog()">📤 Export ZIP</button>
                <button class="btn btn-secondary" onclick="backupData()">💾 Backup</button>
                <button class="btn btn-secondary" onclick="restoreData()">📂 Restore</button>
                <button class="btn btn-danger" onclick="resetFileDatabase()">🔄 Reset DB</button>
				<button class="btn btn-secondary" onclick="updateAllFilePaths()">🔄 Projekte bereinigen</button>
			<button class="btn btn-success" onclick="repairProjectFolders()">🔧 Ordner reparieren</button>
            </div>
			
<!-- =========================== PROJECT META BAR START =========================== -->
<div class="project-meta-bar" id="projectMetaBar" style="display:none;">
    <span class="meta-project" id="metaProjectName"></span>
    <span class="meta-label">| Level:</span>
    <span id="metaLevelName"></span>
    <button class="copy-level-btn" onclick="copyLevelName()">⧉</button>
    <span class="meta-label">| Teil:</span>
    <span id="metaPartNumber"></span>
</div>
<!-- =========================== PROJECT META BAR END =========================== -->



            <!-- Table Controls -->
            <div class="table-controls">
                <div class="sort-controls">
                    <span style="color: #999;">Sortierung:</span>
                    <button class="sort-btn active" onclick="sortTable('position', event)">Position</button>
                    <button class="sort-btn" onclick="sortTable('filename', event)">Dateiname</button>
                    <button class="sort-btn" onclick="sortTable('folder', event)">Ordner</button>
                    <button class="sort-btn" onclick="sortTable('completion', event)">Fertig</button>
                </div>
                <div class="progress-info">
                    <div class="progress-stat" id="totalProgress">0% vollständig</div>
                    <div class="progress-stat" id="folderProgress">0 Ordner</div>
                </div>
            </div>

            <!-- Scan Progress -->
            <div class="scan-progress" id="scanProgress">
                <div class="scan-status" id="scanStatus">Scanne Dateien...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <!-- Table -->
            <div class="table-container">
                <div id="emptyState" class="empty-state">
                    <h3>Keine Dateien im Projekt</h3>
                    <p>Füge Dateien über die Suche oder das Eingabefeld hinzu.</p>
                    <p style="font-size: 14px; color: #888; margin-top: 10px;">
                        💡 Tipps:<br>
                        • Doppelklick auf Zeilennummern (#) um Position zu ändern<br>
                        • Tab/Shift+Tab für Navigation zwischen Textfeldern<br>
                        • Rechtsklick für Kontext-Menü<br>
                        • Leertaste für Audio-Wiedergabe (wenn Zeile ausgewählt)
                    </p>
                </div>
                <table id="fileTable" style="display: none;">
<thead>
    <tr>
        <th width="40">⋮⋮</th>
        <th width="50" title="Doppelklick auf Nummer um Position zu ändern">#</th>
        <th width="30">
            <input type="checkbox" id="selectAll" onchange="toggleSelectAll()">
        </th>
        <th width="30" title="Deutsche Version vorhanden" onclick="toggleCompletionAll()" style="cursor: pointer;">✓</th>
        <th class="sortable">Dateiname</th>
        <th class="sortable">Ordner</th>
        <th>EN Text</th>
        <th>DE Text</th>
        <th width="200" title="Debug: Aufgelöster Pfad">🔍 Aufgelöster Pfad</th>
        <th width="60">Audio</th>
        <th width="60">DE Audio</th>
        <th width="60">Upload</th>
        <th width="50"></th>
    </tr>
</thead>
                    <tbody id="fileTableBody"></tbody>
                </table>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-message">
                    <div class="save-indicator"></div>
                    <span id="statusText">Bereit</span>
                </div>
                <div class="status-info">
                    <span id="fileCount">0 Dateien</span> | 
                    <span id="selectedCount">0 ausgewählt</span> |
                    <span id="accessStatus" class="access-status" onclick="handleAccessStatusClick()" title="Klicken um Dateiberechtigungen zu erneuern">
                        📂 Keine Auswahl
                    </span>
                </div>
            </div>
        </main>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="contextMenuAction('play')">
            <span>▶</span> Audio abspielen
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('copyEN')">
            <span>📄</span> EN Text kopieren
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('copyDE')">
            <span>📄</span> DE Text kopieren
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('pasteEN')">
            <span>📋</span> In EN Text einfügen
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('pasteDE')">
            <span>📋</span> In DE Text einfügen
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('uploadDE')">
            <span>⬆️</span> DE-Datei hochladen
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="contextMenuAction('openFolder')">
            <span>📁</span> In Ordner-Browser öffnen
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="contextMenuAction('delete')">
            <span>🗑️</span> Datei löschen
        </div>
    </div>

    <!-- Import Dialog -->
    <div class="dialog-overlay" id="importDialog">
        <div class="dialog">
            <h3>📥 Daten importieren</h3>
            <p style="margin-bottom: 15px; color: #999;">
                Unterstützte Formate:<br>
                • Wiki-Tabelle (automatische Spalten-Erkennung)<br>
                • Pipe-Liste: <code>Dateiname|EN Text|DE Text</code><br>
                • Der Import erkennt automatisch, welche Spalte die Dateinamen enthält
            </p>
            <textarea id="importData" placeholder="Füge hier deine Daten ein..."></textarea>
            
            <!-- Column Selection (hidden initially) -->
            <div id="columnSelection" style="display: none; margin-top: 20px; padding: 15px; background: #1a1a1a; border: 1px solid #444; border-radius: 6px;">
                <h4 style="color: #ff6b1a; margin-bottom: 15px;">📋 Spalten-Zuordnung</h4>
                <p style="margin-bottom: 15px; color: #999; font-size: 13px;">
                    Bitte wählen Sie aus, welche Spalten welche Inhalte enthalten:
                </p>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #ccc;">Dateinamen-Spalte:</label>
                    <select id="filenameColumn" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #e0e0e0;" onchange="updatePreviewHighlighting()">
                        <option value="">-- Bitte auswählen --</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 3px;">
                        💡 Intelligente Erkennung basierend auf Datenbank und Patterns
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #ccc;">Englischer Text-Spalte:</label>
                    <select id="englishColumn" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #e0e0e0;" onchange="updatePreviewHighlighting()">
                        <option value="">-- Bitte auswählen --</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #ccc;">Deutsche Text-Spalte (optional):</label>
                    <select id="germanColumn" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #e0e0e0;" onchange="updatePreviewHighlighting()">
                        <option value="">-- Keine / Nicht vorhanden --</option>
                    </select>
                </div>
                
                <!-- Preview Table -->
                <div id="previewTable" style="margin-top: 15px;">
                    <h5 style="color: #ff6b1a; margin-bottom: 10px;">🔍 Vorschau (erste 3 Zeilen):</h5>
                    <div style="overflow-x: auto; max-height: 200px; border: 1px solid #444; border-radius: 4px;">
                        <table id="previewTableContent" style="width: 100%; font-size: 12px;">
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="dialog-buttons">
                <button class="btn btn-secondary" onclick="closeImportDialog()">Abbrechen</button>
                <button class="btn" id="analyzeDataBtn" onclick="analyzeImportData()">Analysieren</button>
                <button class="btn btn-success" id="startImportBtn" onclick="startImportProcess()" style="display: none;">Import starten</button>
            </div>
        </div>
    </div>

    <!-- Export Dialog -->
    <div class="dialog-overlay" id="exportDialog">
        <div class="dialog">
            <h3>📤 Audio-Dateien als ZIP exportieren</h3>
            <p style="margin-bottom: 15px; color: #999;">
                Erstellt eine ZIP-Datei mit allen ausgewählten Audio-Dateien und angepassten Dateinamen.
            </p>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px;">Präfix für Dateinamen:</label>
                <input type="text" id="exportPrefix" value="HLA_DE_" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #e0e0e0;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px;">Dateiformat:</label>
                <select id="exportFormat" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #e0e0e0;">
                    <option value="number_folder">001_ordner_dateiname.ext</option>
                    <option value="folder_number">ordner_001_dateiname.ext</option>
                    <option value="prefix_only">präfix_dateiname.ext</option>
                </select>
            </div>
            <div style="margin-bottom: 20px;">
                <label>
                    <input type="checkbox" id="exportCSV" checked> CSV-Datei mit Übersetzungen erstellen
                </label>
            </div>
            
            <!-- Export Progress -->
            <div class="export-progress" id="exportProgress" style="display: none;">
                <div class="export-status" id="exportStatus">Bereite Export vor...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="exportProgressFill"></div>
                </div>
                <div class="file-list" id="exportFileList"></div>
            </div>

            <!-- Download Section -->
            <div class="download-section" id="downloadSection" style="display: none;">
                <div class="download-info">
                    <strong>Export abgeschlossen!</strong><br>
                    ZIP-Datei ist bereit zum Download.
                </div>
                <button class="download-btn" id="downloadBtn" onclick="downloadZip()">
                    📦 ZIP-Datei herunterladen
                </button>
            </div>

            <div class="dialog-buttons">
                <button class="btn btn-secondary" onclick="closeExportDialog()">Abbrechen</button>
                <button class="btn btn-success" id="startExportBtn" onclick="startExport()">Export starten</button>
            </div>
        </div>
    </div>

    <!-- Folder Browser Dialog -->
    <div class="dialog-overlay folder-browser-dialog" id="folderBrowserDialog">
        <div class="dialog">
<!-- =========================== DIALOG CLOSE BTN START =========================== -->
<button class="dialog-close-btn" onclick="closeFolderBrowser()">×</button>
<!-- =========================== DIALOG CLOSE BTN END =========================== -->
	
            <h3 id="folderBrowserTitle">📁 Ordner durchsuchen</h3>
            <p style="margin-bottom: 15px; color: #999;" id="folderBrowserDescription">
                Durchsuchen Sie alle verfügbaren Ordner aus der Datenbank und fügen Sie Dateien zu Ihrem Projekt hinzu.
            </p>
			
<!-- =========================== LEVEL STATS PANEL START =========================== -->
<details class="level-stats" id="levelStatsPanel">
    <summary>📊 Übersetzungs-Statistiken pro Level</summary>
    <div id="levelStatsContent" style="margin-top:15px;"></div>
</details>
<!-- =========================== LEVEL STATS PANEL END =========================== -->

            
            <!-- Back button (hidden initially) -->
            <button class="folder-back-btn" id="folderBackBtn" onclick="showFolderGrid()" style="display: none;">
                ← Zurück zur Ordnerübersicht
            </button>
            
            <!-- Folder Grid -->
            <div class="folder-grid" id="folderGrid"></div>
            
            <!-- Folder Files View (hidden initially) -->
            <div class="folder-files-view" id="folderFilesView"></div>
            
            <div class="dialog-buttons">
                <button class="btn btn-secondary" onclick="standardOrdnerAendern()">Standardordner ändern</button>
                <button class="btn btn-secondary" onclick="closeFolderBrowser()">Schließen</button>
            </div>
        </div>
    </div>

    <!-- Audio Player -->
    <audio id="audioPlayer"></audio>
    <input type="file" id="deUploadInput" style="display:none" accept=".mp3,.wav,.ogg" onchange="handleDeUpload(this)">

    <!-- JSZip Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
	

// =========================== GLOBAL STATE START ===========================
let projects               = [];
let levelColors            = {}; // ⬅️ NEU: globale Level-Farben
let currentProject         = null;
let files                  = [];
let exportZip              = null; // ZIP Export
let textDatabase           = {};
let filePathDatabase       = {}; // Dateiname → Pfade
let audioFileCache         = {}; // Zwischenspeicher für Audio-Dateien
let deAudioCache           = {}; // Zwischenspeicher für DE-Audios
let folderCustomizations   = {}; // Speichert Icons/Farben pro Ordner
let isDirty                = false;

let projektOrdnerHandle    = null; // Gewählter Projektordner
let deOrdnerHandle         = null; // Handle für den DE-Ordner
let enOrdnerHandle         = null; // Handle für den EN-Ordner
let enDateien              = [];   // Gefundene EN-Audiodateien
let aktuellerUploadPfad    = null; // Zielpfad für hochgeladene Dateien

let draggedElement         = null;
let currentlyPlaying       = null;
let selectedRow            = null; // für Tastatur-Navigation
let contextMenuFile        = null; // Rechtsklick-Menü-Datei
let currentSort            = { column: 'position', direction: 'asc' };
let displayOrder           = []; // Original-Dateireihenfolge

// =========================== GLOBAL STATE END ===========================


// =========================== DOM READY INITIALISIERUNG ===========================
document.addEventListener('DOMContentLoaded', async () => {
    loadProjects();

    // 🟩 NEU: Level-Farben laden
    const savedLevelColors = localStorage.getItem('hla_levelColors');
    if (savedLevelColors) {
        levelColors = JSON.parse(savedLevelColors);
    }

    initializeEventListeners();

    // 📁 Ordner-Anpassungen laden
    const savedCustomizations = localStorage.getItem('hla_folderCustomizations');
    if (savedCustomizations) {
        folderCustomizations = JSON.parse(savedCustomizations);
    }

    // 📂 Datei-Pfad-Datenbank laden
    const savedPathDB = localStorage.getItem('hla_filePathDatabase');
    if (savedPathDB) {
        filePathDatabase = JSON.parse(savedPathDB);
    }

    // 👉 Zuletzt verwendeten Projektordner laden
    const savedHandle = await loadProjectFolderHandle();
    if (savedHandle) {
        let perm = await savedHandle.queryPermission({ mode: 'read' });
        if (perm !== 'granted') {
            perm = await savedHandle.requestPermission({ mode: 'read' });
        }

        if (perm === 'granted') {
            const rescan = confirm('Letzten Projektordner erneut scannen?');
            if (rescan) {
                projektOrdnerHandle = savedHandle;
                deOrdnerHandle = await projektOrdnerHandle.getDirectoryHandle('DE', { create: true });
                enOrdnerHandle = await projektOrdnerHandle.getDirectoryHandle('EN', { create: true });
                await scanEnOrdner();
                updateStatus('Projektordner eingelesen und gescannt');
            } else {
                projektOrdnerHandle = savedHandle;
            }
        }
    } else {
        const choose = confirm('Kein Projektordner gefunden. Jetzt auswählen?');
        if (choose) waehleProjektOrdner();
    }

    // 💾 Auto-Save alle 30 Sekunden
    setInterval(saveCurrentProject, 30000);

    // 💡 Speichern beim Verlassen
    window.addEventListener('beforeunload', (e) => {
        if (isDirty) {
            saveCurrentProject();
        }
    });
});
// =========================== DOM READY INITIALISIERUNG ENDE ===========================


/* =========================== LEVEL COLOR HELPERS START =========================== */
function getLevelColor(levelName) {
    // Rückfallfarbe, falls Level noch keine Farbe hat
    return levelColors[levelName] || '#444444';
}

function setLevelColor(levelName, color) {
    levelColors[levelName] = color;

    // Alle Projekte dieses Levels einfärben
    projects.forEach(p => {
        if (p.levelName === levelName) p.color = color;
    });

    saveProjects();
    saveLevelColors();
    renderProjects();        // sofort neu zeichnen
}
/* =========================== LEVEL COLOR HELPERS END =========================== */

// =========================== SAVELEVELCOLORS START ===========================
function saveLevelColors() {
    try {
        // Lokalen Speicher aktualisieren
        localStorage.setItem('hla_levelColors', JSON.stringify(levelColors));
    } catch (e) {
        console.error('[saveLevelColors] Speichern fehlgeschlagen:', e);
    }
}
// =========================== SAVELEVELCOLORS END ===========================



// Berechne Projekt-Statistiken
function calculateProjectStats(project) {
    const files = project.files || [];
    const totalFiles = files.length;
    
    if (totalFiles === 0) {
        return {
            enPercent: 0,
            dePercent: 0,
            completedPercent: 0,
            totalFiles: 0
        };
    }
    
    const filesWithEN = files.filter(f => f.enText && f.enText.trim().length > 0).length;
    const filesWithDE = files.filter(f => f.deText && f.deText.trim().length > 0).length;
    const filesCompleted = files.filter(f => f.completed).length;
    
    return {
        enPercent: Math.round((filesWithEN / totalFiles) * 100),
        dePercent: Math.round((filesWithDE / totalFiles) * 100),
        completedPercent: Math.round((filesCompleted / totalFiles) * 100),
        totalFiles: totalFiles
    };
}

// Handle Access Status Click - für den Button unten rechts
function handleAccessStatusClick() {
    const stats = checkFileAccess();
    
    if (stats.selectedFiles === 0) {
        alert('ℹ️ Dateiberechtigungen\n\nKeine Dateien ausgewählt.\n\nWählen Sie erst Dateien aus, um deren Berechtigung zu prüfen.');
        return;
    }
    
    if (stats.inaccessibleFiles === 0) {
        alert('✅ Dateiberechtigungen\n\nAlle ausgewählten Dateien sind verfügbar!\n\nKein Scan erforderlich.');
        return;
    }
    
    // Auto-scan für nicht verfügbare Dateien
    const shouldScan = confirm(
        `🔒 Dateiberechtigungen erneuern\n\n` +
        `Status: ${stats.accessibleFiles}/${stats.selectedFiles} Dateien verfügbar\n` +
        `${stats.inaccessibleFiles} Dateien benötigen neue Berechtigungen\n\n` +
        `Grund: Browser-Berechtigungen sind abgelaufen oder\n` +
        `Dateien wurden in einem anderen Ordner gefunden.\n\n` +
        `✅ JA - Projektordner wählen\n` +
        `❌ NEIN - Abbrechen\n\n` +
        `Möchten Sie den Ordner-Scan starten?`
    );
    
    if (shouldScan) {
        updateStatus('Erneuere Dateiberechtigungen - Ordner-Scan...');
        setTimeout(() => {
            document.getElementById('folderPicker').click();
        }, 500);
    }
}

// =========================== LOAD PROJECTS START ===========================
function loadProjects() {
    // 🟩 ERST: Level-Farben laden
    const savedLevelColors = localStorage.getItem('hla_levelColors');
    if (savedLevelColors) {
        levelColors = JSON.parse(savedLevelColors);
    }

    // DANN: Projekte laden
    const savedProjects = localStorage.getItem('hla_projects');
    if (savedProjects) {
        projects = JSON.parse(savedProjects);

        let migrated = false;
        projects.forEach(p => {
            if (!p.hasOwnProperty('icon'))  { p.icon  = '🗂️'; migrated = true; }
            if (!p.hasOwnProperty('color')) { p.color = '#333333'; migrated = true; }
            if (!p.hasOwnProperty('levelName')) { p.levelName = ''; migrated = true; }
            if (!p.hasOwnProperty('levelPart')) { p.levelPart = 1;  migrated = true; }
        });

        // 🔥 WICHTIG: Level-Farben auf Projekte anwenden (FIX)
        projects.forEach(p => {
            if (p.levelName && levelColors[p.levelName]) {
                p.color = levelColors[p.levelName];
                migrated = true;
            }
        });

        if (migrated) saveProjects();
    } else {
        projects = [{
            id: Date.now(),
            name: 'Hauptprojekt',
            levelName: '',
            levelPart: 1,
            files: [],
            icon: '🎮',
            color: '#ff6b1a'
        }];
        saveProjects();
    }

    // Text- & Pfaddatenbanken laden (unverändert)
    const savedDB  = localStorage.getItem('hla_textDatabase');
    if (savedDB)  textDatabase = JSON.parse(savedDB);
    const savedPDB = localStorage.getItem('hla_filePathDatabase');
    if (savedPDB) filePathDatabase = JSON.parse(savedPDB);

    renderProjects();

    const lastActive = localStorage.getItem('hla_lastActiveProject');
    const first     = projects.find(p => p.id == lastActive) || projects[0];
    if (first) selectProject(first.id);
}
// =========================== LOAD PROJECTS END ===========================


        function saveProjects() {
            localStorage.setItem('hla_projects', JSON.stringify(projects));
        }

        function saveTextDatabase() {
            localStorage.setItem('hla_textDatabase', JSON.stringify(textDatabase));
        }

        function saveFilePathDatabase() {
            localStorage.setItem('hla_filePathDatabase', JSON.stringify(filePathDatabase));
        }

        function saveFolderCustomizations() {
            localStorage.setItem('hla_folderCustomizations', JSON.stringify(folderCustomizations));
        }

        // =========================== HANDLE-DATENBANK START =====================
        let ordnerHandleDB = null; // IndexedDB-Instanz

        function openOrdnerHandleDB() {
            return new Promise((resolve, reject) => {
                if (ordnerHandleDB) return resolve(ordnerHandleDB);

                const request = indexedDB.open('hla_projectFolder', 1);
                request.onupgradeneeded = () => {
                    request.result.createObjectStore('handles');
                };
                request.onsuccess = () => {
                    ordnerHandleDB = request.result;
                    resolve(ordnerHandleDB);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function saveProjectFolderHandle(handle) {
            const db = await openOrdnerHandleDB();
            const tx = db.transaction('handles', 'readwrite');
            tx.objectStore('handles').put(handle, 'project');
            return new Promise((res, rej) => {
                tx.oncomplete = () => res();
                tx.onerror = () => rej(tx.error);
            });
        }

        async function loadProjectFolderHandle() {
            const db = await openOrdnerHandleDB();
            const tx = db.transaction('handles', 'readonly');
            const req = tx.objectStore('handles').get('project');
            return new Promise((res) => {
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(null);
            });
        }
        // =========================== HANDLE-DATENBANK END =======================

/* =========================== RENDER PROJECTS START =========================== */
function renderProjects() {
    const list = document.getElementById('projectList');
    list.innerHTML = '';

    projects.forEach(p => {
        const stats = calculateProjectStats(p);
        const done  = stats.enPercent === 100 &&
                      stats.dePercent === 100 &&
                      stats.completedPercent === 100;

        /* ► Kachel-Container */
        const card = document.createElement('div');
        card.className = 'project-item';
        if (done) card.classList.add('completed');
        card.dataset.projectId = p.id;
        card.draggable = true;
        card.style.background = getLevelColor(p.levelName);

        /* ► Großes Teil-Badge */
        const badge = `<span class="level-part-badge">${p.levelPart}</span>`;

        /* ► HTML-Inhalt */
        card.innerHTML = `
            ${badge}
            <div style="display:flex;gap:8px;align-items:flex-start;">
                <span style="font-size:16px;">${p.icon || '🗂️'}</span>
                <div style="flex:1;min-width:0;">
                    <div style="font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
                        ${p.name}
                    </div>
                    <div style="font-size:10px;color:rgba(255,255,255,0.8);
                                 margin-top:4px;display:flex;gap:8px;">
                        <span title="EN-Text">${stats.enPercent}%</span>
                        <span title="DE-Text">${stats.dePercent}%</span>
                        <span title="Fertig">${stats.completedPercent}%</span>
                    </div>
                    <div style="font-size:9px;color:rgba(255,255,255,0.6);">
                        ${stats.totalFiles} Dateien
                    </div>
                </div>
            </div>
            <div style="display:flex;gap:5px;">
                <button class="project-customize-btn"
                        onclick="showProjectCustomization(${p.id}, event)">⚙️</button>
                <button class="delete-btn"
                        onclick="deleteProject(${p.id}, event)">×</button>
            </div>
        `;

        /* ► Tooltip */
        card.title =
            `${p.name}\n` +
            (p.levelName ? `Level: ${p.levelName}\n` : '') +
            `Teil:  ${p.levelPart}\n\n` +
            `• EN: ${stats.enPercent}%  • DE: ${stats.dePercent}%\n` +
            `• Fertig: ${stats.completedPercent}%  • Dateien: ${stats.totalFiles}`;

        /* ► Klick / Drag */
        card.onclick = e => {
            if (!e.target.classList.contains('delete-btn') &&
                !e.target.classList.contains('project-customize-btn')) {
                selectProject(p.id);
            }
        };
        card.addEventListener('dragstart', handleProjectDragStart);
        card.addEventListener('dragover',  handleProjectDragOver);
        card.addEventListener('drop',      handleProjectDrop);
        card.addEventListener('dragend',   handleProjectDragEnd);
        card.addEventListener('dragenter', handleProjectDragEnter);
        card.addEventListener('dragleave', handleProjectDragLeave);

        list.appendChild(card);
    });
}
/* =========================== RENDER PROJECTS END =========================== */


/* =========================== GLOBAL TEXT STATS FUNCTIONS START =========================== */
function calculateGlobalTextStats() {
    // Zähle EN/DE/Both/Total über die gesamte Datenbank
    let en = 0, de = 0, both = 0, tot = 0;

    Object.entries(textDatabase).forEach(([fileKey, texts]) => {
        if (ignoredFiles[fileKey]) return;

        const hasEN = texts.en && texts.en.trim().length > 0;
        const hasDE = texts.de && texts.de.trim().length > 0;

        if (hasEN) en++;
        if (hasDE) de++;
        if (hasEN && hasDE) both++;
        tot++;
    });

    return { en, de, both, total: tot };
}

function updateGlobalTextStats() {
    // Suche das Element sowohl in der normalen Ansicht als auch im Dialog
    let box = document.getElementById('globalTextStatsValue');
    
    // Falls nicht gefunden, suche in allen möglichen Containern
    if (!box) {
        box = document.querySelector('.folder-stat-item .folder-stat-number');
    }
    
    if (!box) {
        console.log('[GLOBAL STATS] Element nicht gefunden');
        return;
    }

    const { en, de, both, total } = calculateGlobalTextStats();
    
    console.log(`[GLOBAL STATS] EN: ${en}, DE: ${de}, Both: ${both}, Total: ${total}`);
    box.textContent = `${en} / ${de} / ${both} / ${total}`;
    
    // Auch die Farbe entsprechend setzen
    if (both === total && total > 0) {
        box.style.color = "#4caf50"; // Grün wenn alles übersetzt
    } else if (both > 0) {
        box.style.color = "#ff9800"; // Orange wenn teilweise übersetzt
    } else {
        box.style.color = "#666"; // Grau wenn nichts übersetzt
    }
}
/* =========================== GLOBAL TEXT STATS FUNCTIONS END =========================== */

// =========================== SHOWFOLDERBROWSER START ===========================
function showFolderBrowser() {
    document.getElementById('folderBrowserDialog').style.display = 'flex';
    
    // Debug info
    console.log('Ordner-Browser geöffnet');
    console.log('filePathDatabase Einträge:', Object.keys(filePathDatabase).length);
    console.log('Aktuelle Projektdateien:', files.length);
    console.log('textDatabase Einträge:', Object.keys(textDatabase).length);
    
    // 🔥 KORREKTUR: Erst die Statistiken aktualisieren, dann Grid anzeigen
    renderLevelStats();
    updateGlobalTextStats();
    showFolderGrid();
}
// =========================== SHOWFOLDERBROWSER END ===========================



/* =========================== ADD PROJECT START =========================== */
function addProject() {
    const name = prompt('Projektname:');
    if (!name) return;

    const levelNames = [...new Set(projects.map(p => p.levelName).filter(Boolean))];
    const lvl = prompt('Level-Name (bekannt: ' + (levelNames.join(', ') || '–') + ')') || '';
    const part = parseInt(prompt('Teil-Nummer (1-99):', '1')) || 1;

    const color = getLevelColor(lvl) || '#54428E';    // Default-Farbe, falls neu

    const prj = {
        id: Date.now(),
        name: name.trim(),
        levelName: lvl.trim(),
        levelPart: part,
        files: [],
        icon: '🗂️',
        color: color
    };

    projects.push(prj);
    if (!levelColors[lvl]) setLevelColor(lvl, color);

    saveProjects();
    renderProjects();
    selectProject(prj.id);
}
/* =========================== ADD PROJECT END =========================== */



        function deleteProject(id, event) {
            event.stopPropagation();
            if (projects.length <= 1) {
                alert('Das letzte Projekt kann nicht gelöscht werden!');
                return;
            }
            
            if (!confirm('Projekt wirklich löschen?')) return;
            
            projects = projects.filter(p => p.id !== id);
            saveProjects();
            renderProjects();
            
            if (currentProject && currentProject.id === id) {
                selectProject(projects[0].id);
            }
        }

// =========================== SELECT PROJECT START ===========================
function selectProject(id){
    saveCurrentProject();

    currentProject = projects.find(p => p.id === id);
    if(!currentProject) return;

    localStorage.setItem('hla_lastActiveProject',id);

    document.querySelectorAll('.project-item')
        .forEach(item=>item.classList.toggle('active',item.dataset.projectId==id));

    files = currentProject.files || [];

    // Migration: completed-Flag nachziehen
    let migrated=false;
    files.forEach(f=>{
        if(!f.hasOwnProperty('completed')){f.completed=false;migrated=true;}
    });
    if(migrated) isDirty=true;

    renderFileTable();
    updateStatus();
    updateFileAccessStatus();
    updateProgressStats();
    updateProjectMetaBar();          //  <-- NEU!
}
// =========================== SELECT PROJECT END ===========================


        function saveCurrentProject() {
            if (!currentProject || !isDirty) return;
            
            currentProject.files = files;
            saveProjects();
            saveTextDatabase();
            saveFilePathDatabase();
            isDirty = false;
			updateProjectMetaBar();
        }
		
		
// =========================== PROJECT META FUNCTIONS START ===========================
function updateProjectMetaBar(){
    const bar=document.getElementById('projectMetaBar');
    if(!currentProject){bar.style.display='none';return;}

    document.getElementById('metaProjectName').textContent=currentProject.name||'–';
    document.getElementById('metaLevelName').textContent  =currentProject.levelName||'–';
    document.getElementById('metaPartNumber').textContent =currentProject.levelPart ||1;
    bar.style.display='flex';
}

/* =========================== LEVEL STATS FUNCTIONS START =========================== */
function renderLevelStats() {
    const panel = document.getElementById('levelStatsContent');
    if (!panel) {
        console.log('[LEVEL STATS] Panel nicht gefunden');
        return;
    }

    /* Daten sammeln */
    const map = {};   // lvl => { parts:Set, en,de,both,total,complete }

    projects.forEach(p => {
        if (!p.levelName || !p.files) return;
        
        if (!map[p.levelName]) {
            map[p.levelName] = { 
                parts: new Set(), 
                en: 0, 
                de: 0, 
                both: 0, 
                total: 0, 
                complete: 0 
            };
        }

        const bucket = map[p.levelName];
        bucket.parts.add(p.levelPart);

        p.files.forEach(f => {
            const fileKey = `${f.folder}/${f.filename}`;
            
            // Ignorierte Dateien überspringen
            if (ignoredFiles[fileKey]) return;
            
            const hasEN = f.enText && f.enText.trim().length > 0;
            const hasDE = f.deText && f.deText.trim().length > 0;
            
            if (hasEN) bucket.en++;
            if (hasDE) bucket.de++;
            if (hasEN && hasDE) bucket.both++;
            if (f.completed) bucket.complete++;
            bucket.total++;
        });
    });

    const rows = Object.entries(map);
    if (!rows.length) {
        panel.innerHTML = '<em style="color:#666;">Noch keine Level eingetragen.</em>';
        return;
    }

    /* Tabelle bauen */
    let html = `
        <table style="width:100%;border-collapse:collapse;margin-top:12px;font-size:13px;">
            <tr>
                <th style="padding:6px 8px;border-bottom:1px solid #333;text-align:left;">Level</th>
                <th style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;">Teile</th>
                <th style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;">EN / DE / BEIDE / ∑</th>
                <th style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;">Fertig-%</th>
            </tr>
    `;
    
    rows.forEach(([lvl, b]) => {
        const pct  = b.total ? Math.round(b.complete / b.total * 100) : 0;
        const col  = pct === 100 ? '#4caf50' : pct >= 50 ? '#ff9800' : '#f44336';
        const cols = getLevelColor(lvl);

        html += `
          <tr>
            <td style="padding:6px 8px;border-bottom:1px solid #333;color:${cols};font-weight:600;">${lvl}</td>
            <td style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;">${b.parts.size}</td>
            <td style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;">${b.en} / ${b.de} / ${b.both} / ${b.total}</td>
            <td style="padding:6px 8px;border-bottom:1px solid #333;text-align:center;color:${col};font-weight:600;">${pct}%</td>
          </tr>`;
    });
    
    html += '</table>';
    panel.innerHTML = html;
    
    console.log('[LEVEL STATS] Statistiken aktualisiert:', rows.length, 'Level');
}
/* =========================== LEVEL STATS FUNCTIONS END =========================== */

/* =========================== HANDLE TEXT CHANGE START =========================== */
function handleTextChange(file, field, value) {
    file[field] = value;
    isDirty     = true;

    const key = `${file.folder}/${file.filename}`;
    if (!textDatabase[key]) textDatabase[key] = { en: '', de: '' };
    textDatabase[key][field === 'enText' ? 'en' : 'de'] = value;

    saveTextDatabase();
    updateGlobalTextStats();   // neue Kachel sofort aktualisieren
    updateProgressStats();
    renderLevelStats();
}
/* =========================== HANDLE TEXT CHANGE END =========================== */


function copyLevelName(){
    if(!currentProject||!currentProject.levelName) return;
    navigator.clipboard.writeText(currentProject.levelName)
        .then(()=>updateStatus('Level-Name kopiert'))
        .catch(()=>alert('Kopieren fehlgeschlagen'));
}
// =========================== PROJECT META FUNCTIONS END ===========================




        // File Management
function addFiles() {
    const input = document.getElementById('fileInput').value.trim();
    if (!input) return;
    
    const filenames = input.split('\n').map(f => f.trim()).filter(f => f);
    const foundFiles = [];
    const notFound = [];
    
    filenames.forEach(searchTerm => {
        let found = false;
        
        // Search in file path database
        for (const [filename, paths] of Object.entries(filePathDatabase)) {
            if (filename.toLowerCase().includes(searchTerm.toLowerCase()) ||
                filename.replace(/\.[^/.]+$/, '').toLowerCase().includes(searchTerm.toLowerCase())) {
                
                if (paths.length === 1) {
                    const pathInfo = paths[0];
                    foundFiles.push({
                        filename: filename,
                        folder: pathInfo.folder,
                        fullPath: pathInfo.fullPath
                    });
                    found = true;
                    break;
                }
            }
        }
        
        if (!found) {
            notFound.push(searchTerm);
        }
    });
    
    // Add found files
    let added = 0;
    foundFiles.forEach(({ filename, folder, fullPath }) => {
        if (!files.find(f => f.filename === filename && f.folder === folder)) {
            const fileKey = `${folder}/${filename}`;
            const newFile = {
                id: Date.now() + Math.random(),
                filename: filename,
                folder: folder,
                fullPath: fullPath,
                enText: textDatabase[fileKey]?.en || '',
                deText: textDatabase[fileKey]?.de || '',
                selected: true,
                completed: false
            };
            
            files.push(newFile);
            added++;
        }
    });
    
    if (added > 0) {
        isDirty = true;
        renderFileTable();
        renderProjects(); // HINZUGEFÜGT für live Update
        updateStatus(`${added} Dateien hinzugefügt`);
        updateProgressStats();
    }
    
    if (notFound.length > 0) {
        setTimeout(() => {
            alert(`Folgende Dateien wurden nicht gefunden:\n${notFound.join('\n')}\n\nBitte prüfen Sie den EN-Ordner des Projekts.`);
        }, 100);
    }
    
    document.getElementById('fileInput').value = '';
}

        // Enhanced search with similarity matching
        function calculateSimilarity(str1, str2) {
            // Normalize strings: lowercase, remove punctuation
            const normalize = (str) => str.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').trim();
            
            const s1 = normalize(str1);
            const s2 = normalize(str2);
            
            // Exact match after normalization
            if (s1 === s2) return 1.0;
            
            // Contains match
            if (s1.includes(s2) || s2.includes(s1)) return 0.8;
            
            // Word-based similarity
            const words1 = s1.split(/\s+/);
            const words2 = s2.split(/\s+/);
            
            let commonWords = 0;
            words1.forEach(word1 => {
                if (words2.some(word2 => word1.includes(word2) || word2.includes(word1))) {
                    commonWords++;
                }
            });
            
            const wordSimilarity = commonWords / Math.max(words1.length, words2.length);
            
            // Character-based similarity (Levenshtein-inspired)
            const maxLen = Math.max(s1.length, s2.length);
            if (maxLen === 0) return 1.0;
            
            let matches = 0;
            const minLen = Math.min(s1.length, s2.length);
            for (let i = 0; i < minLen; i++) {
                if (s1[i] === s2[i]) matches++;
            }
            
            const charSimilarity = matches / maxLen;
            
            // Combined similarity
            return Math.max(wordSimilarity, charSimilarity);
        }

        // Search functionality with highlighting and similarity
        function highlightText(text, query) {
            if (!text || !query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<span class="search-result-match">$1</span>');
        }

        function initializeEventListeners() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    return;
                }
                
                const results = [];
                const exactMatches = [];
                const similarMatches = [];
                
                // Search in file path database
                Object.entries(filePathDatabase).forEach(([filename, paths]) => {
                    paths.forEach(pathInfo => {
                        const fileKey = `${pathInfo.folder}/${filename}`;
                        const text = textDatabase[fileKey];
                        
                        // Normalize query for comparison
                        const normalizedQuery = query.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').trim();
                        
                        // Check if filename, EN text, or DE text contains the query
                        const filenameMatch = filename.toLowerCase().includes(normalizedQuery);
                        const enTextMatch = text?.en?.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').includes(normalizedQuery);
                        const deTextMatch = text?.de?.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').includes(normalizedQuery);
                        
                        let matchInfo = null;
                        
                        if (filenameMatch || enTextMatch || deTextMatch) {
                            // Exact matches
                            if (filenameMatch) {
                                matchInfo = {
                                    type: 'Dateiname',
                                    preview: highlightText(filename, query),
                                    similarity: 1.0
                                };
                            } else if (enTextMatch) {
                                const enText = text.en;
                                const index = enText.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').indexOf(normalizedQuery);
                                const start = Math.max(0, index - 30);
                                const end = Math.min(enText.length, index + query.length + 30);
                                matchInfo = {
                                    type: 'EN Text',
                                    preview: '...' + highlightText(enText.substring(start, end), query) + '...',
                                    similarity: 1.0
                                };
                            } else if (deTextMatch) {
                                const deText = text.de;
                                const index = deText.toLowerCase().replace(/[.,!?;:"'\-()]/g, '').indexOf(normalizedQuery);
                                const start = Math.max(0, index - 30);
                                const end = Math.min(deText.length, index + query.length + 30);
                                matchInfo = {
                                    type: 'DE Text',
                                    preview: '...' + highlightText(deText.substring(start, end), query) + '...',
                                    similarity: 1.0
                                };
                            }
                            
                            exactMatches.push({
                                filename,
                                folder: pathInfo.folder,
                                fullPath: pathInfo.fullPath,
                                text,
                                matchType: matchInfo.type,
                                matchPreview: matchInfo.preview,
                                similarity: matchInfo.similarity
                            });
                        } else {
                            // Check for similar matches
                            let bestSimilarity = 0;
                            let bestMatch = null;
                            
                            // Check filename similarity
                            const filenameSim = calculateSimilarity(filename, query);
                            if (filenameSim > bestSimilarity && filenameSim >= 0.4) {
                                bestSimilarity = filenameSim;
                                bestMatch = {
                                    type: 'Dateiname (ähnlich)',
                                    preview: filename,
                                    similarity: filenameSim
                                };
                            }
                            
                            // Check EN text similarity
                            if (text?.en) {
                                const enSim = calculateSimilarity(text.en, query);
                                if (enSim > bestSimilarity && enSim >= 0.4) {
                                    bestSimilarity = enSim;
                                    bestMatch = {
                                        type: 'EN Text (ähnlich)',
                                        preview: text.en.length > 60 ? text.en.substring(0, 60) + '...' : text.en,
                                        similarity: enSim
                                    };
                                }
                            }
                            
                            // Check DE text similarity
                            if (text?.de) {
                                const deSim = calculateSimilarity(text.de, query);
                                if (deSim > bestSimilarity && deSim >= 0.4) {
                                    bestSimilarity = deSim;
                                    bestMatch = {
                                        type: 'DE Text (ähnlich)',
                                        preview: text.de.length > 60 ? text.de.substring(0, 60) + '...' : text.de,
                                        similarity: deSim
                                    };
                                }
                            }
                            
                            if (bestMatch) {
                                similarMatches.push({
                                    filename,
                                    folder: pathInfo.folder,
                                    fullPath: pathInfo.fullPath,
                                    text,
                                    matchType: bestMatch.type,
                                    matchPreview: bestMatch.preview,
                                    similarity: bestMatch.similarity
                                });
                            }
                        }
                    });
                });
                
                // Combine and sort results
                const allResults = [...exactMatches, ...similarMatches.sort((a, b) => b.similarity - a.similarity)];
                
                if (allResults.length > 0) {
                    searchResults.innerHTML = allResults.slice(0, 20).map(r => `
                        <div class="search-result-item" onclick='addFromSearch(${JSON.stringify(r).replace(/'/g, "&#39;")})'>
                            <div class="search-result-filename">
                                ${r.filename}
                                ${r.similarity < 1.0 ? `<span class="search-result-similarity">${Math.round(r.similarity * 100)}% ähnlich</span>` : ''}
                            </div>
                            <div class="search-result-path">${r.folder} • ${r.matchType}</div>
                            <div class="search-result-text">${r.matchPreview}</div>
                        </div>
                    `).join('');
                    searchResults.style.display = 'block';
                } else {
                    searchResults.innerHTML = '<div class="search-result-item">Keine Ergebnisse gefunden</div>';
                    searchResults.style.display = 'block';
                }
            });
            
            // Close search results on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-container')) {
                    searchResults.style.display = 'none';
                }
            });

            // Auto-resize textarea
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';
            });
            
            // Keyboard navigation
            document.addEventListener('keydown', handleKeyboardNavigation);
            
            // Context menu
            document.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', hideContextMenu);
        }

        // Keyboard Navigation
        function handleKeyboardNavigation(e) {
            // Skip if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // Tab navigation between text fields
                if (e.key === 'Tab') {
                    handleTabNavigation(e);
                }
                // Space for audio in text fields
                if (e.key === ' ' && e.ctrlKey) {
                    e.preventDefault();
                    const row = e.target.closest('tr');
                    if (row) {
                        const fileId = parseFloat(row.dataset.id);
                        playAudio(fileId);
                    }
                }
                return;
            }
            
            // Global shortcuts
            if (e.ctrlKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveCurrentProject();
                        updateStatus('Gespeichert');
                        break;
                    case 'i':
                        e.preventDefault();
                        showImportDialog();
                        break;
                    case 'e':
                        e.preventDefault();
                        showExportDialog();
                        break;
                    case 'f':
                        e.preventDefault();
                        showFolderBrowser();
                        break;
                }
                return;
            }
            
            // Table navigation
            const tbody = document.getElementById('fileTableBody');
            if (!tbody || files.length === 0) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            let currentIndex = selectedRow ? rows.indexOf(selectedRow) : -1;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    currentIndex = Math.max(0, currentIndex - 1);
                    selectRow(rows[currentIndex]);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    currentIndex = Math.min(rows.length - 1, currentIndex + 1);
                    selectRow(rows[currentIndex]);
                    break;
                case ' ':
                    e.preventDefault();
                    if (selectedRow) {
                        const fileId = parseFloat(selectedRow.dataset.id);
                        playAudio(fileId);
                    }
                    break;
                case 'Delete':
                    e.preventDefault();
                    if (selectedRow) {
                        const fileId = parseFloat(selectedRow.dataset.id);
                        deleteFile(fileId);
                    }
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedRow) {
                        // Focus first text input in selected row
                        const firstInput = selectedRow.querySelector('.text-input');
                        if (firstInput) {
                            firstInput.focus();
                        }
                    }
                    break;
                case 'Escape':
                    document.querySelectorAll('.dialog-overlay').forEach(d => {
                        d.style.display = 'none';
                    });
                    hideContextMenu();
                    break;
            }
        }

        function handleTabNavigation(e) {
            const row = e.target.closest('tr');
            if (!row) return;
            
            const inputs = row.querySelectorAll('.text-input');
            const currentIndex = Array.from(inputs).indexOf(e.target);
            
            if (e.shiftKey) {
                // Shift+Tab - go to previous field or previous row
                if (currentIndex > 0) {
                    e.preventDefault();
                    inputs[currentIndex - 1].focus();
                } else {
                    // Go to last field of previous row
                    const prevRow = row.previousElementSibling;
                    if (prevRow) {
                        e.preventDefault();
                        const prevInputs = prevRow.querySelectorAll('.text-input');
                        if (prevInputs.length > 0) {
                            prevInputs[prevInputs.length - 1].focus();
                        }
                    }
                }
            } else {
                // Tab - go to next field or next row
                if (currentIndex < inputs.length - 1) {
                    e.preventDefault();
                    inputs[currentIndex + 1].focus();
                } else {
                    // Go to first field of next row
                    const nextRow = row.nextElementSibling;
                    if (nextRow) {
                        e.preventDefault();
                        const nextInputs = nextRow.querySelectorAll('.text-input');
                        if (nextInputs.length > 0) {
                            nextInputs[0].focus();
                        }
                    }
                }
            }
        }

        function selectRow(row) {
            if (selectedRow) {
                selectedRow.classList.remove('selected-row');
            }
            selectedRow = row;
            if (selectedRow) {
                selectedRow.classList.add('selected-row');
                selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Copy button functionality
        async function copyTextToClipboard(fileId, language) {
            console.log('Copy button clicked - FileID:', fileId, 'Language:', language);
            
            // Find file more safely
            const file = files.find(f => f && f.id && f.id == fileId);
            if (!file) {
                console.error('File not found for copy operation. FileID:', fileId);
                console.log('Available files:', files.map(f => ({id: f?.id, filename: f?.filename})));
                updateStatus(`Fehler: Datei nicht gefunden (ID: ${fileId})`);
                return;
            }
            
            console.log('Found file for copy:', file.filename, 'ID:', file.id);
            
            const text = language === 'en' ? (file.enText || '') : (file.deText || '');
            const langLabel = language === 'en' ? 'EN' : 'DE';
            
            if (!text) {
                updateStatus(`${langLabel} Text ist leer für ${file.filename}`);
                return;
            }
            
            try {
                await navigator.clipboard.writeText(text);
                updateStatus(`${langLabel} Text kopiert: ${file.filename}`);
                console.log('Copy successful:', langLabel, 'from', file.filename);
                
                // Visual feedback - briefly highlight the copy button
                const button = event.target;
                if (button) {
                    const originalBg = button.style.background;
                    const originalText = button.textContent;
                    button.style.background = '#4caf50';
                    button.textContent = '✓';
                    
                    setTimeout(() => {
                        button.style.background = originalBg;
                        button.textContent = originalText;
                    }, 1000);
                }
                
            } catch (err) {
                console.error('Copy failed:', err);
                updateStatus(`${langLabel} Kopieren fehlgeschlagen: ${file.filename}`);
                
                // Error feedback
                const button = event.target;
                if (button) {
                    const originalBg = button.style.background;
                    const originalText = button.textContent;
                    button.style.background = '#f44336';
                    button.textContent = '✗';
                    
                    setTimeout(() => {
                        button.style.background = originalBg;
                        button.textContent = originalText;
                    }, 1000);
                }
            }
        }

        // Context Menu
        function handleContextMenu(e) {
            const row = e.target.closest('tr[data-id]');
            if (!row) return;
            
            e.preventDefault();
            
            const fileIdStr = row.dataset.id;
            const fileId = parseFloat(fileIdStr);
            
            console.log('Context menu - Row data-id:', fileIdStr, 'Parsed as:', fileId);
            
            // Find file more safely
            contextMenuFile = files.find(f => f && f.id && f.id == fileId);
            
            if (!contextMenuFile) {
                console.error('Context menu file not found for ID:', fileId);
                console.log('Available files:', files.map(f => ({id: f?.id, filename: f?.filename})));
                return;
            }
            
            console.log('Context menu opened for file:', contextMenuFile.filename, 'ID:', contextMenuFile.id);
            
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
            
            // Ensure menu stays within viewport
            const rect = contextMenu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                contextMenu.style.left = (e.pageX - rect.width) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                contextMenu.style.top = (e.pageY - rect.height) + 'px';
            }
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            contextMenuFile = null;
        }

        async function contextMenuAction(action) {
            if (!contextMenuFile) {
                console.error('No context menu file available for action:', action);
                updateStatus('Fehler: Keine Datei für Aktion verfügbar');
                return;
            }
            
            console.log('Context menu action:', action, 'for file:', contextMenuFile.filename);
            hideContextMenu();
            
            try {
                switch(action) {
                    case 'play':
                        playAudio(contextMenuFile.id);
                        break;
                    case 'copyEN':
                        if (!contextMenuFile.enText) {
                            updateStatus(`EN Text ist leer für ${contextMenuFile.filename}`);
                            return;
                        }
                        await navigator.clipboard.writeText(contextMenuFile.enText);
                        updateStatus(`EN Text kopiert: ${contextMenuFile.filename}`);
                        break;
                    case 'copyDE':
                        if (!contextMenuFile.deText) {
                            updateStatus(`DE Text ist leer für ${contextMenuFile.filename}`);
                            return;
                        }
                        await navigator.clipboard.writeText(contextMenuFile.deText);
                        updateStatus(`DE Text kopiert: ${contextMenuFile.filename}`);
                        break;
                    case 'pasteEN':
                        const enText = await navigator.clipboard.readText();
                        if (!enText) {
                            updateStatus('Zwischenablage ist leer');
                            return;
                        }
                        updateText(contextMenuFile.id, 'en', enText);
                        renderFileTable();
                        updateStatus(`Text in EN eingefügt: ${contextMenuFile.filename}`);
                        break;
                    case 'pasteDE':
                        const deText = await navigator.clipboard.readText();
                        if (!deText) {
                            updateStatus('Zwischenablage ist leer');
                            return;
                        }
                        updateText(contextMenuFile.id, 'de', deText);
                        renderFileTable();
                        updateStatus(`Text in DE eingefügt: ${contextMenuFile.filename}`);
                        break;
                    case 'uploadDE':
                        aktuellerUploadPfad = `${contextMenuFile.folder}/${contextMenuFile.filename}`;
                        document.getElementById('deUploadInput').click();
                        break;
                    case 'openFolder':
                        showFolderBrowser();
                        // Wait a bit then show the specific folder
                        setTimeout(() => {
                            showFolderFiles(contextMenuFile.folder);
                        }, 100);
                        break;
                    case 'delete':
                        if (confirm(`Datei "${contextMenuFile.filename}" wirklich löschen?`)) {
                            deleteFile(contextMenuFile.id);
                        }
                        break;
                    default:
                        console.warn('Unknown context menu action:', action);
                }
            } catch (err) {
                console.error('Context menu action failed:', action, err);
                updateStatus(`Aktion fehlgeschlagen: ${action}`);
            }
        }

        // Table Sorting
        function sortTable(column, evt) {
            const target = evt.target;
            // Update sort buttons
            document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
            target.classList.add('active');
            
            // Determine sort direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }
            
            // Store original display order before sorting
            if (displayOrder.length === 0) {
                displayOrder = files.map((file, index) => ({ file, originalIndex: index }));
            }
            
            // Sort files for display only
            let sortedFiles = [...files];
            
            switch(column) {
                case 'position':
                    // Reset to original order
                    sortedFiles = displayOrder.map(item => item.file);
                    break;
                case 'filename':
                    sortedFiles.sort((a, b) => {
                        const result = a.filename.localeCompare(b.filename);
                        return currentSort.direction === 'asc' ? result : -result;
                    });
                    break;
                case 'folder':
                    sortedFiles.sort((a, b) => {
                        const result = a.folder.localeCompare(b.folder);
                        return currentSort.direction === 'asc' ? result : -result;
                    });
                    break;
                case 'completion':
                    sortedFiles.sort((a, b) => {
                        const aCompleted = a.completed ? 1 : 0;
                        const bCompleted = b.completed ? 1 : 0;
                        const result = bCompleted - aCompleted;
                        return currentSort.direction === 'asc' ? -result : result;
                    });
                    break;
            }
            
            // Update table header indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            if (column !== 'position') {
                const header = target.closest('th') ||
                             document.querySelector(`th[onclick*="${column}"]`);
                if (header) {
                    header.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
            
            // Render with sorted order (but keep original files array unchanged)
            renderFileTableWithOrder(sortedFiles);
        }

// =========================== RENDER FILE TABLE WITH ORDER START ===========================
function renderFileTableWithOrder(sortedFiles) {
    const tbody = document.getElementById('fileTableBody');
    const table = document.getElementById('fileTable');
    const emptyState = document.getElementById('emptyState');
    
    if (sortedFiles.length === 0) {
        table.style.display = 'none';
        emptyState.style.display = 'block';
        return;
    }
    
    table.style.display = 'table';
    emptyState.style.display = 'none';
    
    tbody.innerHTML = sortedFiles.map((file, displayIndex) => {
        const relPath = `${file.folder}/${file.filename}`;
        const hasDeAudio = !!deAudioCache[relPath];
        // Find original index for display
        const originalIndex = files.findIndex(f => f.id === file.id);
        
        const folderParts = file.folder.split('/');
        const lastFolder = folderParts[folderParts.length - 1] || folderParts[folderParts.length - 2] || 'unknown';
        
        // Get custom folder settings
        const customization = folderCustomizations[file.folder] || {};
        let folderIcon = customization.icon;
        let folderColor = customization.color;
        
        // Get default icon and color if no custom ones set
        if (!folderIcon) {
            if (lastFolder.toLowerCase().includes('gman')) folderIcon = '👤';
            else if (lastFolder.toLowerCase().includes('alyx')) folderIcon = '👩';
            else if (lastFolder.toLowerCase().includes('russell')) folderIcon = '👨‍🔬';
            else if (lastFolder.toLowerCase().includes('eli')) folderIcon = '👨‍🦳';
            else if (lastFolder.toLowerCase().includes('vortigaunt')) folderIcon = '👽';
            else if (lastFolder.toLowerCase().includes('combine')) folderIcon = '🤖';
            else if (lastFolder.toLowerCase().includes('jeff')) folderIcon = '🧟';
            else if (lastFolder.toLowerCase().includes('zombie')) folderIcon = '🧟‍♂️';
            else folderIcon = '📁';
        }
        
        if (!folderColor) {
            // Default colors based on folder name
            if (lastFolder.toLowerCase().includes('gman')) folderColor = '#4a148c';
            else if (lastFolder.toLowerCase().includes('alyx')) folderColor = '#1a237e';
            else if (lastFolder.toLowerCase().includes('russell')) folderColor = '#00695c';
            else if (lastFolder.toLowerCase().includes('eli')) folderColor = '#e65100';
            else if (lastFolder.toLowerCase().includes('vortigaunt')) folderColor = '#263238';
            else if (lastFolder.toLowerCase().includes('combine')) folderColor = '#b71c1c';
            else if (lastFolder.toLowerCase().includes('jeff')) folderColor = '#2e7d32';
            else if (lastFolder.toLowerCase().includes('zombie')) folderColor = '#424242';
            else folderColor = '#333';
        }
        
return `
    <tr data-id="${file.id}" ${file.completed ? 'class="completed"' : ''}>
        <td class="drag-handle" draggable="true">⋮⋮</td>
        <td class="row-number" data-file-id="${file.id}" ondblclick="changeRowNumber(${file.id}, ${originalIndex + 1})" title="Doppelklick um Position zu ändern">${originalIndex + 1}</td>
        <td><input type="checkbox" ${file.selected ? 'checked' : ''} onchange="toggleFileSelection(${file.id})"></td>
        <td><input type="checkbox" class="completion-checkbox" ${file.completed ? 'checked' : ''} onchange="toggleFileCompletion(${file.id})" title="Deutsche Version vorhanden"></td>
        <td>${file.filename}</td>
        <td>
            <span class="folder-badge clickable" 
                  style="background: ${folderColor}; color: white;"
                  title="Ordner: ${file.folder} - Klick für Datei-Austausch"
                  onclick="showFileExchangeOptions(${file.id})">
                ${folderIcon} ${lastFolder}
            </span>
        </td>
        <td><div style="position: relative; display: flex; align-items: flex-start; gap: 5px;">
            <textarea class="text-input" 
                 onchange="updateText(${file.id}, 'en', this.value)" 
                 oninput="autoResizeInput(this)">${escapeHtml(file.enText)}</textarea>
            <button class="copy-btn" onclick="copyTextToClipboard(${file.id}, 'en')" title="EN Text kopieren">📋</button>
        </div></td>
        <td><div style="position: relative; display: flex; align-items: flex-start; gap: 5px;">
            <textarea class="text-input" 
                 onchange="updateText(${file.id}, 'de', this.value)"
                 oninput="autoResizeInput(this)">${escapeHtml(file.deText)}</textarea>
            <button class="copy-btn" onclick="copyTextToClipboard(${file.id}, 'de')" title="DE Text kopieren">📋</button>
        </div></td>
        <td style="font-size: 11px; color: #666; word-break: break-all;">
            ${getDebugPathInfo(file)}
        </td>
        <td><button class="play-btn" onclick="playAudio(${file.id})">▶</button></td>
        <td>
            ${hasDeAudio ? `<button class="de-play-btn" onclick="playDeAudio(${file.id})">▶</button>` : ''}
        </td>
        <td><button class="upload-btn" onclick="initiateDeUpload(${file.id})">⬆️</button></td>
        <td><button class="delete-row-btn" onclick="deleteFile(${file.id})">×</button></td>
    </tr>
`;
    }).join('');
    
    addDragAndDropHandlers();
    updateCounts();
    
    // Auto-resize all text inputs after rendering
    setTimeout(() => {
        autoResizeAllInputs();
    }, 50);
}
// =========================== RENDER FILE TABLE WITH ORDER END ===========================

// =========================== FILE EXCHANGE FUNCTIONALITY START ===========================

let fileExchangeData = {
    currentFile: null,
    similarEntries: [],
    selectedEntry: null
};

// =========================== SHOW FILE EXCHANGE OPTIONS START ===========================
function showFileExchangeOptions(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) {
        console.error('Datei nicht gefunden:', fileId);
        return;
    }
    
    // Prüfe ob EN-Text vorhanden ist
    if (!file.enText || file.enText.trim().length === 0) {
        alert('❌ Datei-Austausch nicht möglich\n\nDiese Datei hat keinen EN-Text zum Vergleichen.\nBitte fügen Sie zuerst einen englischen Text hinzu.');
        return;
    }
    
    console.log(`[FILE EXCHANGE] Suche ähnliche Einträge für: ${file.filename}`);
    console.log(`[FILE EXCHANGE] EN-Text: ${file.enText.substring(0, 50)}...`);
    
    // Suche ähnliche Einträge in der Datenbank
    const similarEntries = searchSimilarEntriesInDatabase(file);
    
    if (similarEntries.length === 0) {
        alert('❌ Keine ähnlichen Einträge gefunden\n\nEs wurden keine Dateien in der Datenbank gefunden, die ähnliche EN-Texte haben.\n\nTipp: Importieren Sie zuerst mehr Daten oder scannen Sie weitere Ordner.');
        return;
    }
    
    console.log(`[FILE EXCHANGE] Gefunden: ${similarEntries.length} ähnliche Einträge`);
    
    // Zeige Dialog mit Optionen
    displayFileExchangeDialog(file, similarEntries);
}
// =========================== SHOW FILE EXCHANGE OPTIONS END ===========================

// =========================== SEARCH SIMILAR ENTRIES START ===========================
function searchSimilarEntriesInDatabase(currentFile) {
    const currentEnText = currentFile.enText.trim().toLowerCase();
    const similarEntries = [];
    const currentFileKey = `${currentFile.folder}/${currentFile.filename}`;
    
    // Durchsuche alle Einträge in der textDatabase
    Object.entries(textDatabase).forEach(([fileKey, texts]) => {
        // Überspringe die aktuelle Datei selbst
        if (fileKey === currentFileKey) return;
        
        // Überspringe Einträge ohne EN-Text
        if (!texts.en || texts.en.trim().length === 0) return;
        
        const dbEnText = texts.en.trim().toLowerCase();
        
        // Berechne Ähnlichkeit
        const similarity = calculateTextSimilarity(currentEnText, dbEnText);
        
        // Nur Einträge mit mindestens 30% Ähnlichkeit berücksichtigen
        if (similarity >= 0.3) {
            // Extrahiere Dateiname und Ordner aus fileKey
            const pathParts = fileKey.split('/');
            const filename = pathParts.pop();
            const folder = pathParts.join('/');
            
            similarEntries.push({
                fileKey: fileKey,
                filename: filename,
                folder: folder,
                enText: texts.en,
                deText: texts.de || '',
                similarity: similarity,
                similarityPercent: Math.round(similarity * 100)
            });
        }
    });
    
    // Sortiere nach Ähnlichkeit (höchste zuerst)
    similarEntries.sort((a, b) => b.similarity - a.similarity);
    
    // Begrenze auf maximal 20 Einträge
    return similarEntries.slice(0, 20);
}
// =========================== SEARCH SIMILAR ENTRIES END ===========================

// =========================== CALCULATE TEXT SIMILARITY START ===========================
function calculateTextSimilarity(text1, text2) {
    // Normalisiere beide Texte
    const normalize = (text) => {
        return text.toLowerCase()
                   .replace(/[^\w\s]/g, '') // Entferne Satzzeichen
                   .replace(/\s+/g, ' ')    // Mehrfache Leerzeichen zu einem
                   .trim();
    };
    
    const norm1 = normalize(text1);
    const norm2 = normalize(text2);
    
    // Exakte Übereinstimmung
    if (norm1 === norm2) return 1.0;
    
    // Enthaltensein-Test
    if (norm1.includes(norm2) || norm2.includes(norm1)) {
        const shorter = norm1.length < norm2.length ? norm1 : norm2;
        const longer = norm1.length >= norm2.length ? norm1 : norm2;
        return shorter.length / longer.length;
    }
    
    // Wort-basierte Ähnlichkeit
    const words1 = norm1.split(/\s+/);
    const words2 = norm2.split(/\s+/);
    
    let commonWords = 0;
    const allWords = new Set([...words1, ...words2]);
    
    words1.forEach(word1 => {
        if (words2.some(word2 => 
            word1.includes(word2) || 
            word2.includes(word1) || 
            levenshteinDistance(word1, word2) <= Math.max(1, Math.min(word1.length, word2.length) * 0.3)
        )) {
            commonWords++;
        }
    });
    
    const maxWords = Math.max(words1.length, words2.length);
    const wordSimilarity = commonWords / maxWords;
    
    // Levenshtein-Distanz für Zeichen-Ähnlichkeit
    const maxLength = Math.max(norm1.length, norm2.length);
    const editDistance = levenshteinDistance(norm1, norm2);
    const charSimilarity = (maxLength - editDistance) / maxLength;
    
    // Kombiniere beide Metriken
    return Math.max(wordSimilarity, charSimilarity * 0.7);
}

// Hilfsfunktion: Levenshtein-Distanz
function levenshteinDistance(str1, str2) {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= str2.length; j++) {
        for (let i = 1; i <= str1.length; i++) {
            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
                matrix[j][i - 1] + 1,     // deletion
                matrix[j - 1][i] + 1,     // insertion
                matrix[j - 1][i - 1] + indicator // substitution
            );
        }
    }
    
    return matrix[str2.length][str1.length];
}
// =========================== CALCULATE TEXT SIMILARITY END ===========================

// =========================== DISPLAY FILE EXCHANGE DIALOG START ===========================
function displayFileExchangeDialog(currentFile, similarEntries) {
    fileExchangeData.currentFile = currentFile;
    fileExchangeData.similarEntries = similarEntries;
    fileExchangeData.selectedEntry = null;
    
    // Erstelle Dialog-HTML
    const dialogHTML = `
        <div class="file-exchange-dialog" id="fileExchangeDialog">
            <div class="file-exchange-content">
                <h3>🔄 Datei-Austausch: ${currentFile.filename}</h3>
                
                <div class="current-file-info">
                    <h4>📄 Aktuelle Datei</h4>
                    <div><strong>Dateiname:</strong> ${currentFile.filename}</div>
                    <div><strong>Ordner:</strong> ${currentFile.folder}</div>
                    <div class="entry-text en"><strong>EN:</strong> ${currentFile.enText}</div>
                    <div class="entry-text de"><strong>DE:</strong> ${currentFile.deText || '(leer)'}</div>
                </div>
                
                <h4>🔍 Ähnliche Einträge in der Datenbank (${similarEntries.length} gefunden)</h4>
                <p style="color: #999; margin-bottom: 15px;">
                    Klicken Sie auf einen Eintrag, um die Datei auszutauschen. 
                    Der EN-Text wird aus der Datenbank übernommen, der DE-Text bleibt erhalten.
                </p>
                
                <div class="similar-entries-list">
                    ${similarEntries.map((entry, index) => `
                        <div class="similar-entry-item" onclick="selectExchangeEntry(${index})">
                            <div class="similarity-score ${entry.similarityPercent >= 80 ? 'high' : entry.similarityPercent >= 50 ? 'medium' : 'low'}">
                                ${entry.similarityPercent}%
                            </div>
                            <div class="entry-filename">${entry.filename}</div>
                            <div class="entry-folder">📁 ${entry.folder}</div>
                            <div class="entry-text en">
                                <strong>EN:</strong> ${entry.enText}
                            </div>
                            <div class="entry-text de">
                                <strong>DE:</strong> ${entry.deText || '(leer)'}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="exchange-preview" id="exchangePreview">
                    <h4>🔄 Vorschau der Änderungen</h4>
                    <div class="exchange-changes">
                        <div class="change-item old">
                            <strong>Alt (wird ersetzt):</strong>
                            <div id="oldPreview"></div>
                        </div>
                        <div class="change-item new">
                            <strong>Neu (aus Datenbank):</strong>
                            <div id="newPreview"></div>
                        </div>
                    </div>
                </div>
                
                <div class="dialog-buttons">
                    <button class="btn btn-secondary" onclick="closeFileExchangeDialog()">Abbrechen</button>
                    <button class="btn btn-success" id="executeExchangeBtn" onclick="executeFileExchange()" disabled>
                        Austausch durchführen
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Füge Dialog zum DOM hinzu
    document.body.insertAdjacentHTML('beforeend', dialogHTML);
    
    // Zeige Dialog
    document.getElementById('fileExchangeDialog').style.display = 'flex';
    
    updateStatus(`Datei-Austausch geöffnet: ${similarEntries.length} ähnliche Einträge gefunden`);
}
// =========================== DISPLAY FILE EXCHANGE DIALOG END ===========================

// =========================== SELECT EXCHANGE ENTRY START ===========================
function selectExchangeEntry(index) {
    const entries = document.querySelectorAll('.similar-entry-item');
    
    // Entferne alte Auswahl
    entries.forEach(entry => entry.classList.remove('selected'));
    
    // Markiere neue Auswahl
    entries[index].classList.add('selected');
    
    // Speichere ausgewählten Eintrag
    fileExchangeData.selectedEntry = fileExchangeData.similarEntries[index];
    
    // Zeige Vorschau
    showExchangePreview();
    
    // Aktiviere Austausch-Button
    document.getElementById('executeExchangeBtn').disabled = false;
    
    console.log(`[FILE EXCHANGE] Ausgewählt: ${fileExchangeData.selectedEntry.filename} (${fileExchangeData.selectedEntry.similarityPercent}% Ähnlichkeit)`);
}
// =========================== SELECT EXCHANGE ENTRY END ===========================

// =========================== SHOW EXCHANGE PREVIEW START ===========================
function showExchangePreview() {
    const preview = document.getElementById('exchangePreview');
    const oldPreview = document.getElementById('oldPreview');
    const newPreview = document.getElementById('newPreview');
    
    if (!fileExchangeData.selectedEntry) return;
    
    const current = fileExchangeData.currentFile;
    const selected = fileExchangeData.selectedEntry;
    
    oldPreview.innerHTML = `
        <div><strong>Dateiname:</strong> ${current.filename}</div>
        <div><strong>Ordner:</strong> ${current.folder}</div>
        <div><strong>EN:</strong> ${current.enText}</div>
        <div><strong>DE:</strong> ${current.deText || '(leer)'}</div>
    `;
    
    newPreview.innerHTML = `
        <div><strong>Dateiname:</strong> ${selected.filename}</div>
        <div><strong>Ordner:</strong> ${selected.folder}</div>
        <div><strong>EN:</strong> ${selected.enText}</div>
        <div><strong>DE:</strong> ${current.deText || '(bleibt erhalten)'}</div>
    `;
    
    preview.style.display = 'block';
}
// =========================== SHOW EXCHANGE PREVIEW END ===========================

// =========================== EXECUTE FILE EXCHANGE START ===========================
function executeFileExchange() {
    if (!fileExchangeData.currentFile || !fileExchangeData.selectedEntry) {
        alert('❌ Fehler: Keine Auswahl getroffen');
        return;
    }
    
    const current = fileExchangeData.currentFile;
    const selected = fileExchangeData.selectedEntry;
    
    // Bestätigung
    const confirmMessage = `🔄 Datei-Austausch bestätigen\n\n` +
        `Aktuelle Datei: ${current.filename}\n` +
        `Ordner: ${current.folder}\n\n` +
        `Wird ersetzt durch:\n` +
        `Neue Datei: ${selected.filename}\n` +
        `Ordner: ${selected.folder}\n` +
        `Ähnlichkeit: ${selected.similarityPercent}%\n\n` +
        `Änderungen:\n` +
        `• EN-Text: Wird aus Datenbank übernommen\n` +
        `• DE-Text: Bleibt erhalten (${current.deText ? 'vorhanden' : 'leer'})\n` +
        `• Dateiname & Ordner: Werden geändert\n\n` +
        `Fortfahren?`;
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // Führe Austausch durch
    console.log(`[FILE EXCHANGE] Tausche aus: ${current.filename} → ${selected.filename}`);
    
    // 1. Aktualisiere die Datei im aktuellen Projekt
    current.filename = selected.filename;
    current.folder = selected.folder;
    current.enText = selected.enText;
    // DE-Text bleibt erhalten: current.deText = current.deText;
    
    // 2. Markiere als dirty für Speicherung
    isDirty = true;
    
    // 3. Aktualisiere textDatabase mit dem erhaltenen DE-Text
    const newFileKey = `${selected.folder}/${selected.filename}`;
    if (!textDatabase[newFileKey]) {
        textDatabase[newFileKey] = {};
    }
    textDatabase[newFileKey].en = selected.enText;
    if (current.deText) {
        textDatabase[newFileKey].de = current.deText;
    }
    
    // 4. Speichere Änderungen
    saveTextDatabase();
    saveCurrentProject();
    
    // 5. Aktualisiere UI
    renderFileTable();
    renderProjects();
    updateProgressStats();
    
    // 6. Schließe Dialog
    closeFileExchangeDialog();
    
    // 7. Erfolgs-Nachricht
    const successMessage = `✅ Datei-Austausch erfolgreich!\n\n` +
        `Alte Datei: ${current.filename}\n` +
        `Neue Datei: ${selected.filename}\n` +
        `Ordner: ${selected.folder}\n` +
        `Ähnlichkeit: ${selected.similarityPercent}%\n\n` +
        `✓ EN-Text aus Datenbank übernommen\n` +
        `✓ DE-Text beibehalten\n` +
        `✓ Projekt aktualisiert`;
    
    updateStatus(`Datei-Austausch erfolgreich: ${selected.filename} (${selected.similarityPercent}% Ähnlichkeit)`);
    
    setTimeout(() => {
        alert(successMessage);
    }, 500);
    
    console.log(`[FILE EXCHANGE] Erfolgreich: ${current.filename} in ${current.folder}`);
}
// =========================== EXECUTE FILE EXCHANGE END ===========================

// =========================== CLOSE FILE EXCHANGE DIALOG START ===========================
function closeFileExchangeDialog() {
    const dialog = document.getElementById('fileExchangeDialog');
    if (dialog) {
        dialog.remove();
    }
    
    // Reset data
    fileExchangeData = {
        currentFile: null,
        similarEntries: [],
        selectedEntry: null
    };
    
    updateStatus('Datei-Austausch abgebrochen');
}
// =========================== CLOSE FILE EXCHANGE DIALOG END ===========================

// =========================== FILE EXCHANGE FUNCTIONALITY END ===========================

// Debug: Zeige aufgelösten Pfad für Datei
function getDebugPathInfo(file) {
    if (!filePathDatabase[file.filename]) {
        return '❌ Nicht in DB';
    }
    
    const dbPaths = filePathDatabase[file.filename];
    
    // Suche passende Pfade
    const exactMatches = dbPaths.filter(pathInfo => pathInfo.folder === file.folder);
    const normalizedMatches = dbPaths.filter(pathInfo => {
        const normalizedFileFolder = normalizeFolderPath(file.folder);
        const normalizedDbFolder = normalizeFolderPath(pathInfo.folder);
        return normalizedFileFolder === normalizedDbFolder;
    });
    
    if (exactMatches.length > 0) {
        const bestPath = exactMatches[0];
        const isAudioAvailable = !!audioFileCache[bestPath.fullPath];
        const status = isAudioAvailable ? '✅' : '❌';
        return `${status} EXAKT<br><small>${bestPath.fullPath}</small>`;
    }
    
    if (normalizedMatches.length > 0) {
        const bestPath = normalizedMatches[0];
        const isAudioAvailable = !!audioFileCache[bestPath.fullPath];
        const status = isAudioAvailable ? '✅' : '⚠️';
        return `${status} NORMALISIERT<br><small>Projekt: ${file.folder}<br>DB: ${bestPath.folder}</small>`;
    }
    
    // Keine Matches - zeige was verfügbar ist
    const availableFolders = dbPaths.map(p => p.folder).join('<br>');
    return `❌ KEINE MATCHES<br><small>Projekt: ${file.folder}<br>DB hat:<br>${availableFolders}</small>`;
}

// Repariere Ordnernamen in allen Projekten basierend auf Database
function repairProjectFolders() {
    if (!confirm('Dies aktualisiert alle Ordnernamen in den Projekten basierend auf der Database.\nFortfahren?')) {
        return;
    }
    
    let totalUpdated = 0;
    let totalProjects = 0;
    const updateLog = [];
    
    console.log('=== Repariere Projekt-Ordnernamen ===');
    
    projects.forEach(project => {
        if (!project.files || project.files.length === 0) return;
        
        totalProjects++;
        let projectUpdated = 0;
        
        project.files.forEach(file => {
            if (!filePathDatabase[file.filename]) {
                console.log(`❌ ${file.filename} nicht in Database gefunden`);
                return;
            }
            
            const dbPaths = filePathDatabase[file.filename];
            
            // Suche beste Übereinstimmung
            let bestMatch = null;
            
            // 1. Exakte Übereinstimmung
            const exactMatch = dbPaths.find(p => p.folder === file.folder);
            if (exactMatch) {
                bestMatch = exactMatch;
            } else {
                // 2. Normalisierte Übereinstimmung
                const normalizedFileFolder = normalizeFolderPath(file.folder);
                const normalizedMatch = dbPaths.find(p => {
                    const normalizedDbFolder = normalizeFolderPath(p.folder);
                    return normalizedFileFolder === normalizedDbFolder;
                });
                
                if (normalizedMatch) {
                    bestMatch = normalizedMatch;
                } else {
                    // 3. Ähnlichkeits-Matching (falls Ordnername teilweise übereinstimmt)
                    const similarMatch = dbPaths.find(p => {
                        const fileFolder = file.folder.toLowerCase();
                        const dbFolder = p.folder.toLowerCase();
                        return fileFolder.includes(dbFolder.split('/').pop()) || 
                               dbFolder.includes(fileFolder);
                    });
                    
                    if (similarMatch) {
                        bestMatch = similarMatch;
                    } else {
                        // 4. Fallback: Nimm ersten verfügbaren Pfad
                        bestMatch = dbPaths[0];
                    }
                }
            }
            
            // Aktualisiere Ordnernamen wenn nötig
            if (bestMatch && bestMatch.folder !== file.folder) {
                const oldFolder = file.folder;
                file.folder = bestMatch.folder;
                projectUpdated++;
                totalUpdated++;
                
                updateLog.push(`${project.name}: ${file.filename} | ${oldFolder} → ${bestMatch.folder}`);
                console.log(`✅ ${project.name}: ${file.filename} | ${oldFolder} → ${bestMatch.folder}`);
            }
        });
        
        if (projectUpdated > 0) {
            console.log(`📁 Projekt "${project.name}": ${projectUpdated} Ordner aktualisiert`);
        }
    });
    
    if (totalUpdated > 0) {
        // Speichere alle aktualisierten Projekte
        saveProjects();
        console.log(`🎯 Gesamt: ${totalUpdated} Ordnernamen in ${totalProjects} Projekten aktualisiert`);
        
        // Aktualisiere das aktuelle Projekt
        if (currentProject) {
            const updatedProject = projects.find(p => p.id === currentProject.id);
            if (updatedProject) {
                files = updatedProject.files || [];
                renderFileTable();
                updateProgressStats();
                updateFileAccessStatus();
            }
        }
        
        updateStatus(`📁 Ordner-Reparatur: ${totalUpdated} Ordnernamen aktualisiert`);
        
        // Zeige Zusammenfassung
        const logPreview = updateLog.slice(0, 10).join('\n');
        const moreText = updateLog.length > 10 ? `\n... und ${updateLog.length - 10} weitere` : '';
        
        alert(`✅ Ordner-Reparatur erfolgreich!\n\n` +
              `📊 Statistik:\n` +
              `• ${totalUpdated} Ordnernamen aktualisiert\n` +
              `• ${totalProjects} Projekte verarbeitet\n\n` +
              `🔧 Beispiele:\n${logPreview}${moreText}\n\n` +
              `🎯 Audio sollte jetzt in allen Projekten funktionieren!`);
    } else {
        alert('✅ Alle Ordnernamen sind bereits korrekt!\n\nKeine Aktualisierungen nötig.');
    }
    
    console.log('=== Ordner-Reparatur abgeschlossen ===');
}

function addFromSearch(result) {
    if (files.find(f => f.filename === result.filename && f.folder === result.folder)) {
        updateStatus('Datei bereits im Projekt');
        return;
    }
    
    const fileKey = `${result.folder}/${result.filename}`;
    const newFile = {
        id: Date.now() + Math.random(),
        filename: result.filename,
        folder: result.folder,
        // fullPath wird NICHT mehr gespeichert - wird dynamisch geladen
        enText: textDatabase[fileKey]?.en || '',
        deText: textDatabase[fileKey]?.de || '',
        selected: true,
        completed: false
    };
    
    files.push(newFile);
    
    // Update display order for new file
    displayOrder.push({ file: newFile, originalIndex: files.length - 1 });
    
    isDirty = true;
    renderFileTable();
    renderProjects(); // HINZUGEFÜGT für live Update
    updateStatus('Datei hinzugefügt');
    updateProgressStats();
    
    document.getElementById('searchInput').value = '';
    document.getElementById('searchResults').style.display = 'none';
}


// =========================== EXTRACTRELEVANTFOLDER START ===========================
function extractRelevantFolder(folderParts, fullPath) {
    if (folderParts.length === 0) return 'root';
    
    // Known character/location names for Half-Life Alyx
    const knownCharacters = [
        'alyx', 'gman', 'russell', 'eli', 'vortigaunt', 'combine', 
        'jeff', 'zombie', 'larry', 'suppressor', 'strider', 'grunt',
        'officer', 'charger', 'contractor', 'drone', 'overwatch'
    ];
    
    const knownLocations = [
        'city', 'quarantine', 'hotel', 'sewers', 'refinery', 'vault',
        'zoo', 'northern_star', 'residential', 'distillery'
    ];
    
    const knownFolders = [...knownCharacters, ...knownLocations, 'vo', 'sounds', 'music', 'ambient'];
    
    // WICHTIG: Für combine Ordner, behalte die Unterordner-Struktur
    let voIndex = -1;
    let combineIndex = -1;
    
    for (let i = 0; i < folderParts.length; i++) {
        const part = folderParts[i].toLowerCase();
        if (part === 'vo') {
            voIndex = i;
        }
        if (part === 'combine') {
            combineIndex = i;
        }
    }
    
    // Spezialbehandlung für combine mit Unterordnern
    if (combineIndex >= 0 && folderParts.length > combineIndex + 1) {
        const nextPart = folderParts[combineIndex + 1].toLowerCase();
        // Wenn nach combine ein bekannter Unterordner kommt, nimm beide
        if (['charger', 'officer', 'grunt', 'suppressor', 'drone', 'contractor', 'overwatch'].includes(nextPart)) {
            if (voIndex >= 0) {
                return `vo/combine/${folderParts[combineIndex + 1]}`;
            } else {
                return `combine/${folderParts[combineIndex + 1]}`;
            }
        }
    }
    
    // Strategy 1: Look for vo/character pattern
    let characterIndex = -1;
    
    for (let i = 0; i < folderParts.length; i++) {
        const part = folderParts[i].toLowerCase();
        if (knownCharacters.includes(part) && part !== 'combine') {
            characterIndex = i;
        }
    }
    
    // If we found vo and character, create normalized path
    if (voIndex >= 0 && characterIndex >= 0 && characterIndex > voIndex) {
        const character = folderParts[characterIndex];
        return `vo/${character}`;
    }
    
    // Strategy 2: Look for known character/location names
    for (let i = folderParts.length - 1; i >= 0; i--) {
        const part = folderParts[i].toLowerCase();
        if (knownCharacters.includes(part) && part !== 'combine') {
            // Found character, create normalized vo path
            return `vo/${folderParts[i]}`;
        }
    }
    
    // Strategy 3: Look for 'vo' or 'sounds' and take everything from there
    for (let i = 0; i < folderParts.length; i++) {
        const part = folderParts[i].toLowerCase();
        if (part === 'vo') {
            const remaining = folderParts.slice(i);
            // Nimm bis zu 3 Ebenen nach 'vo' (z.B. vo/combine/charger)
            const relevantParts = remaining.slice(0, 4); // vo + 3 weitere
            return relevantParts.join('/');
        } else if (part === 'sounds' && i < folderParts.length - 1) {
            const nextPart = folderParts[i + 1].toLowerCase();
            if (nextPart === 'vo') {
                // Skip sounds/ prefix for vo folders
                const remaining = folderParts.slice(i + 1);
                const relevantParts = remaining.slice(0, 4); // vo + 3 weitere
                return relevantParts.join('/');
            }
        }
    }
    
    // Strategy 4: Look for any known folder names and include subfolders
    for (let i = folderParts.length - 1; i >= 0; i--) {
        const part = folderParts[i].toLowerCase();
        if (knownFolders.includes(part)) {
            const startIndex = Math.max(0, i - 1);
            // Nimm mehr Kontext mit (bis zu 3 Ebenen)
            const endIndex = Math.min(folderParts.length, i + 3);
            return folderParts.slice(startIndex, endIndex).join('/');
        }
    }
    
    // Strategy 5: Take the last 3 meaningful folders
    if (folderParts.length >= 3) {
        // Skip generic folders like 'Projekte', 'Neu', 'OneDrive'
        const genericFolders = ['projekte', 'neu', 'onedrive', 'documents', 'desktop', 'downloads'];
        let meaningfulParts = [];
        
        for (let i = folderParts.length - 1; i >= 0 && meaningfulParts.length < 3; i--) {
            const part = folderParts[i].toLowerCase();
            if (!genericFolders.includes(part)) {
                meaningfulParts.unshift(folderParts[i]);
            }
        }
        
        if (meaningfulParts.length > 0) {
            return meaningfulParts.join('/');
        }
    }
    
    // Strategy 6: Fallback - take last 3 folders
    if (folderParts.length >= 3) {
        return folderParts.slice(-3).join('/');
    } else if (folderParts.length >= 2) {
        return folderParts.slice(-2).join('/');
    }
    
    // Strategy 7: Final fallback - take last folder
    return folderParts[folderParts.length - 1] || 'unknown';
}
// =========================== EXTRACTRELEVANTFOLDER END ===========================

// =========================== NORMALIZEFOLDERPATH START ===========================
// Consistent folder normalization for duplicate detection
function normalizeFolderPath(folderPath) {
    if (!folderPath) return 'unknown';
    
    console.log(`[NORMALIZE] Input: ${folderPath}`);
    
    // Convert to lowercase for comparison
    let normalized = folderPath.toLowerCase();
    
    // WICHTIG: Entferne ALLE möglichen Präfixe die zu Problemen führen können
    // Diese Liste muss alle möglichen Scan-Ebenen abdecken
    const prefixesToRemove = [
        /^.*\/sounds\/vo\//,     // z.B. "Projekte/Neu/sounds/vo/" -> ""
        /^sounds\/vo\//,         // "sounds/vo/" -> ""
        /^.*\/vo\//,            // z.B. "Projekte/Neu/vo/" -> ""
        /^vo\//,                // "vo/" -> "" (bleibt aber erhalten wenn nichts danach kommt)
        /^.*\/sounds\//,        // z.B. "path/to/sounds/" -> ""
        /^sounds\//             // "sounds/" -> ""
    ];
    
    // Speichere Original für Fallback
    const originalNormalized = normalized;
    
    // Versuche Präfixe zu entfernen
    for (const regex of prefixesToRemove) {
        const before = normalized;
        normalized = normalized.replace(regex, '');
        if (before !== normalized) {
            console.log(`[NORMALIZE] Removed prefix: ${before} -> ${normalized}`);
            break; // Nur ersten Match anwenden
        }
    }
    
    // Wenn nach Präfix-Entfernung nichts übrig ist, nutze letzten Teil des Original-Pfads
    if (normalized === '' || normalized === '/') {
        const parts = originalNormalized.split('/');
        normalized = parts[parts.length - 1] || parts[parts.length - 2] || 'unknown';
        console.log(`[NORMALIZE] Empty after prefix removal, using last part: ${normalized}`);
    }
    
    // Entferne führende/trailing slashes
    normalized = normalized.replace(/^\/+|\/+$/g, '');
    
    // Spezialfall: Wenn der normalisierte Pfad nur ein Charakter-Name ist (z.B. "alyx"),
    // füge "vo/" prefix hinzu für Konsistenz
    const characterNames = [
        'alyx', 'gman', 'russell', 'eli', 'vortigaunt', 'combine', 
        'combineleader', 'jeff', 'zombie', 'larry', 'suppressor', 
        'grunt', 'officer', 'charger', 'contractor', 'drone', 
        'olga', 'overwatch', 'citizen', 'scientist'
    ];
    
    if (characterNames.includes(normalized)) {
        normalized = `vo/${normalized}`;
        console.log(`[NORMALIZE] Added vo/ prefix to character: ${normalized}`);
    }
    
    // Finale Normalisierung: Stelle sicher dass bekannte Charaktere immer als "vo/character" erscheinen
    for (const character of characterNames) {
        if (normalized.endsWith(`/${character}`) || normalized === character) {
            normalized = `vo/${character}`;
            console.log(`[NORMALIZE] Final normalization to: ${normalized}`);
            break;
        }
    }
    
    console.log(`[NORMALIZE] Output: ${normalized}`);
    return normalized;
}
// =========================== NORMALIZEFOLDERPATH END ===========================

// =========================== CLEANUPMISSINGFOLDERS START ===========================
// Bereinige nicht mehr gefundene Ordner ohne Texte
function cleanupMissingFolders(scannedFiles) {
    const { en: globalEN, de: globalDE, both: globalBoth, total: globalTotal } = calculateGlobalTextStats();
    const scannedFolders = new Set();

    // Sammle alle Ordner aus dem aktuellen Scan
    Array.from(scannedFiles).forEach(file => {
        if (file.webkitRelativePath.match(/\.(mp3|wav|ogg)$/i)) {
            let fullPath = file.webkitRelativePath;
            // Sprach-Präfixe entfernen, damit die Ordner passen
            if (fullPath.startsWith('EN/')) fullPath = fullPath.slice(3);
            if (fullPath.startsWith('DE/')) fullPath = fullPath.slice(3);
            const parts = fullPath.split('/');
            const folderParts = parts.slice(0, -1);
            const folder = extractRelevantFolder(folderParts, fullPath);
            const normalizedFolder = normalizeFolderPath(folder);
            scannedFolders.add(normalizedFolder);
            scannedFolders.add(folder); // Auch Original-Ordner hinzufügen
        }
    });
    
    console.log(`[CLEANUP] Gefundene Ordner im Scan: ${Array.from(scannedFolders).join(', ')}`);
    console.log(`[GLOBAL STATS] EN: ${globalEN}, DE: ${globalDE}, Both: ${globalBoth}, Total: ${globalTotal}`);
    
    // Finde Ordner in Database die nicht mehr gescannt wurden
    const existingFolders = new Set();
    Object.values(filePathDatabase).forEach(paths => {
        paths.forEach(pathInfo => {
            existingFolders.add(pathInfo.folder);
        });
    });
    
    // Finde verwaiste Ordner (normalisiert vergleichen)
    const missingFolders = Array.from(existingFolders).filter(folder => {
        const normalizedExisting = normalizeFolderPath(folder);
        // Prüfe ob der Ordner oder seine normalisierte Version im Scan gefunden wurde
        return !scannedFolders.has(folder) && !scannedFolders.has(normalizedExisting);
    });
    
    if (missingFolders.length === 0) {
        console.log('[CLEANUP] Keine verwaisten Ordner gefunden');
        return { deletedFolders: 0, keptFolders: 0 };
    }
    
    let deletedFolders = 0;
    let keptFolders = 0;
    
    console.log(`[CLEANUP] Prüfe ${missingFolders.length} verwaiste Ordner...`);
    
    missingFolders.forEach(folder => {
        // Prüfe ob Ordner EN/DE Texte enthält
        let hasTexts = false;
        
        Object.entries(textDatabase).forEach(([fileKey, texts]) => {
            if (fileKey.startsWith(folder + '/')) {
                if ((texts.en && texts.en.trim()) || (texts.de && texts.de.trim())) {
                    hasTexts = true;
                }
            }
        });
        
        // Prüfe auch ob Ordner in einem Projekt verwendet wird
        let isInProject = false;
        projects.forEach(project => {
            if (project.files && project.files.some(file => file.folder === folder)) {
                isInProject = true;
            }
        });
        
        if (!hasTexts && !isInProject) {
            // Lösche alle Dateien aus diesem Ordner aus filePathDatabase
            Object.keys(filePathDatabase).forEach(filename => {
                const originalLength = filePathDatabase[filename].length;
                filePathDatabase[filename] = filePathDatabase[filename].filter(pathInfo => 
                    pathInfo.folder !== folder
                );
                
                // Entferne leere Einträge
                if (filePathDatabase[filename].length === 0) {
                    delete filePathDatabase[filename];
                }
            });
            
            // Lösche aus audioFileCache
            Object.keys(audioFileCache).forEach(fullPath => {
                if (fullPath.includes(folder)) {
                    delete audioFileCache[fullPath];
                }
            });
            
            // Lösche Ordner-Anpassungen
            if (folderCustomizations[folder]) {
                delete folderCustomizations[folder];
            }
            
            deletedFolders++;
            console.log(`[CLEANUP] Gelöscht: ${folder} (keine Texte/Projekte)`);
        } else {
            keptFolders++;
            const reason = hasTexts ? 'enthält Texte' : 'in Projekt verwendet';
            console.log(`[CLEANUP] Behalten: ${folder} (${reason})`);
        }
    });
    
    console.log(`[CLEANUP] Bereinigung abgeschlossen: ${deletedFolders} gelöscht, ${keptFolders} behalten`);
    return { deletedFolders, keptFolders };
}
// =========================== CLEANUPMISSINGFOLDERS END ===========================

// =========================== CLEANUPMISSINGFILES START ===========================
// Entferne Dateieinträge ohne vorhandene Datei und ohne EN/DE-Texte
function cleanupMissingFiles(scannedFiles) {
    // 1. Alle tatsächlich gefundenen Pfade des Scans sammeln
    //    EN/DE-Präfixe werden entfernt, damit die Pfade zu unserer Datenbank passen
    const scannedPaths = new Set(
        Array.from(scannedFiles)
             .map(f => {
                 let p = f.webkitRelativePath;
                 if (p.startsWith('EN/')) p = p.slice(3);
                 if (p.startsWith('DE/')) p = p.slice(3);
                 return p;
             })
    );

    let deletedCount = 0;

    // 2. Durch alle Datenbank-Einträge iterieren
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        filePathDatabase[filename] = paths.filter(pathInfo => {
            const fileExists = scannedPaths.has(pathInfo.fullPath);

            if (fileExists) {
                // Datei ist physisch vorhanden → behalten
                return true;
            }

            // Prüfen, ob es Texte gibt
            const fileKey = `${pathInfo.folder}/${filename}`;
            const texts   = textDatabase[fileKey] || {};
            const hasText = (texts.en && texts.en.trim()) ||
                            (texts.de && texts.de.trim());

            if (hasText) {
                // Es existiert ein Text → Eintrag behalten
                return true;
            }

            // Weder Datei noch Texte → Eintrag löschen
            if (audioFileCache[pathInfo.fullPath]) {
                delete audioFileCache[pathInfo.fullPath];
            }

            // Auch aus allen Projekten entfernen
            projects.forEach(project => {
                if (project.files) {
                    project.files = project.files.filter(f =>
                        !(f.filename === filename && f.folder === pathInfo.folder)
                    );
                }
            });

            console.log(`[CLEANUP-FILES] Entfernt: ${filename} (${pathInfo.folder}) – kein Audio, keine Texte`);
            deletedCount++;
            return false;   // <- Eintrag wird gefiltert
        });

        // Leere Arrays aus der Datenbank räumen
        if (filePathDatabase[filename].length === 0) {
            delete filePathDatabase[filename];
        }
    });

    if (deletedCount > 0) {
        saveFilePathDatabase();
        saveProjects();
    }

    console.log(`[CLEANUP-FILES] ${deletedCount} verwaiste Dateieinträge gelöscht`);
    return deletedCount;
}
// =========================== CLEANUPMISSINGFILES END ===========================



// =========================== FINDAUDIOINFILEPATHCACHE START ===========================
// Helper function to find audio file in cache with flexible matching
function findAudioInFilePathCache(filename, folder) {
    console.log(`[FINDAUDIO] Searching for: ${filename} in folder: ${folder}`);
    
    // 1. Versuche direkte Übereinstimmungen in filePathDatabase
    if (filePathDatabase[filename]) {
        const paths = filePathDatabase[filename];
        console.log(`[FINDAUDIO] Found ${paths.length} paths in database`);
        
        // Sortiere Pfade nach Priorität mit Ordner-Präferenz
        const sortedPaths = paths.sort((a, b) => {
            // HÖCHSTE PRIORITÄT: Exakte Ordner-Übereinstimmung
            if (a.folder === folder && b.folder !== folder) return -1;
            if (a.folder !== folder && b.folder === folder) return 1;
            
            // ZWEITE PRIORITÄT: Normalisierte Ordner-Übereinstimmung
            const normalizedFolder = normalizeFolderPath(folder);
            const normalizedA = normalizeFolderPath(a.folder);
            const normalizedB = normalizeFolderPath(b.folder);
            
            if (normalizedA === normalizedFolder && normalizedB !== normalizedFolder) return -1;
            if (normalizedA !== normalizedFolder && normalizedB === normalizedFolder) return 1;
            
            // DRITTE PRIORITÄT: Ordner-Ähnlichkeit (enthält gleiche Endung)
            const folderEndA = a.folder.split('/').pop();
            const folderEndB = b.folder.split('/').pop();
            const requestedEnd = folder.split('/').pop();
            
            if (folderEndA === requestedEnd && folderEndB !== requestedEnd) return -1;
            if (folderEndA !== requestedEnd && folderEndB === requestedEnd) return 1;
            
            // VIERTE PRIORITÄT: Kürzere Pfade bevorzugen
            return a.folder.length - b.folder.length;
        });
        
        // Prüfe alle Pfade in sortierter Reihenfolge
        for (const pathInfo of sortedPaths) {
            if (audioFileCache[pathInfo.fullPath]) {
                console.log(`[FINDAUDIO] Found audio in cache: ${pathInfo.fullPath} (folder: ${pathInfo.folder})`);
                
                // WARNUNG: Wenn nicht exakte Ordner-Übereinstimmung
                if (pathInfo.folder !== folder) {
                    console.warn(`[FINDAUDIO] Using different folder: requested "${folder}", using "${pathInfo.folder}"`);
                }
                
                return {
                    audioFile: audioFileCache[pathInfo.fullPath],
                    resolvedPath: pathInfo.fullPath,
                    resolvedFolder: pathInfo.folder,
                    isExactMatch: pathInfo.folder === folder
                };
            }
        }
    }
    
    // 2. Fallback: Durchsuche audioFileCache direkt mit flexiblem Matching
    console.log(`[FINDAUDIO] No direct match, searching cache with flexible matching...`);
    
    const normalizedFolder = normalizeFolderPath(folder);
    const possiblePaths = [];
    
    for (const [cachePath, audioFile] of Object.entries(audioFileCache)) {
        const pathLower = cachePath.toLowerCase();
        
        // Prüfe ob Dateiname im Pfad enthalten ist
        if (pathLower.includes(filename.toLowerCase())) {
            // Extrahiere Ordner aus Cache-Pfad
            const pathParts = cachePath.split('/');
            const fileIndex = pathParts.findIndex(part => 
                part.toLowerCase() === filename.toLowerCase()
            );
            
            if (fileIndex > 0) {
                const cacheFolder = pathParts.slice(0, fileIndex).join('/');
                const normalizedCacheFolder = normalizeFolderPath(cacheFolder);
                
                console.log(`[FINDAUDIO] Cache path: ${cachePath}`);
                console.log(`[FINDAUDIO] Cache folder: ${cacheFolder} -> ${normalizedCacheFolder}`);
                console.log(`[FINDAUDIO] Looking for: ${folder} -> ${normalizedFolder}`);
                
                // Bewerte Übereinstimmung
                let score = 0;
                let isExactMatch = false;
                
                if (cacheFolder === folder) {
                    score = 100; // Exakte Übereinstimmung
                    isExactMatch = true;
                } else if (normalizedCacheFolder === normalizedFolder) {
                    score = 80; // Normalisierte Übereinstimmung
                } else if (cacheFolder.endsWith(folder.split('/').pop())) {
                    score = 60; // Endung stimmt überein
                } else if (folder.endsWith(cacheFolder.split('/').pop())) {
                    score = 40; // Enthält Zielpfad
                } else {
                    score = 20; // Schwache Übereinstimmung
                }
                
                possiblePaths.push({
                    path: cachePath,
                    audioFile: audioFile,
                    folder: cacheFolder,
                    score: score,
                    isExactMatch: isExactMatch,
                    folderLength: cacheFolder.length
                });
            }
        }
    }
    
    // Sortiere mögliche Pfade nach Score, dann nach Genauigkeit
    possiblePaths.sort((a, b) => {
        if (a.score !== b.score) return b.score - a.score;
        if (a.isExactMatch !== b.isExactMatch) return a.isExactMatch ? -1 : 1;
        return a.folderLength - b.folderLength;
    });
    
    if (possiblePaths.length > 0) {
        const best = possiblePaths[0];
        console.log(`[FINDAUDIO] Found via flexible matching: ${best.path} (score: ${best.score})`);
        
        if (!best.isExactMatch) {
            console.warn(`[FINDAUDIO] Using approximate match: requested "${folder}", using "${best.folder}"`);
        }
        
        return {
            audioFile: best.audioFile,
            resolvedPath: best.path,
            resolvedFolder: best.folder,
            isExactMatch: best.isExactMatch
        };
    }
    
    console.log(`[FINDAUDIO] No audio found for ${filename} in ${folder}`);
    return null;
}
// =========================== FINDAUDIOINFILEPATHCACHE END ===========================

    // Tabellenanzeige
    function renderFileTable() {
        // Reset display order when rendering normally
        displayOrder = files.map((file, index) => ({ file, originalIndex: index }));
        renderFileTableWithOrder(files);
    }

function addDragAndDropHandlers() {
    const tbody = document.getElementById('fileTableBody');
    tbody.querySelectorAll('.drag-handle').forEach(handle => {
        const row = handle.closest('tr');
        
        handle.addEventListener('dragstart', (e) => {
            draggedElement = row;
            row.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', row.innerHTML);
        });
        
        handle.addEventListener('dragend', (e) => {
            row.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        });
        
        // Row drop zone handlers
        row.addEventListener('dragover', handleDragOver);
        row.addEventListener('drop', handleDrop);
    });
}

        // Text editing
function updateText(fileId, lang, value) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;
    
    if (lang === 'en') {
        file.enText = value;
    } else {
        file.deText = value;
    }
    
    // Update global database
    const fileKey = `${file.folder}/${file.filename}`;
    if (!textDatabase[fileKey]) {
        textDatabase[fileKey] = {};
    }
    textDatabase[fileKey][lang] = value;
    
    isDirty = true;
    updateProgressStats();
    renderProjects(); // HINZUFÜGEN für live Update
}

        // File completion status
function toggleFileCompletion(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;
    
    file.completed = !file.completed;
    isDirty = true;
    
    // Update row appearance
    const row = document.querySelector(`tr[data-id="${fileId}"]`);
    if (row) {
        if (file.completed) {
            row.classList.add('completed');
        } else {
            row.classList.remove('completed');
        }
    }
    
    updateProgressStats();
    renderProjects(); // HINZUFÜGEN für live Update
    updateStatus(file.completed ? 'Als fertig markiert' : 'Als unfertig markiert');
    
    // Update folder browser if it's open
    const folderBrowserOpen = document.getElementById('folderBrowserDialog').style.display === 'flex';
    if (folderBrowserOpen) {
        // Check if we're in folder grid or file view
        const folderFilesView = document.getElementById('folderFilesView');
        if (folderFilesView.style.display === 'block') {
            // We're in file view - refresh it
            showFolderFiles(file.folder);
        } else {
            // We're in grid view - refresh it
            showFolderGrid();
        }
    }
}

        // Progress statistics
        function updateProgressStats() {
            const totalFiles = files.length;
            const completedFiles = files.filter(f => f.completed).length;
            const completionPercent = totalFiles > 0 ? Math.round((completedFiles / totalFiles) * 100) : 0;
            
            // Get folder statistics
            const folderStats = {};
            files.forEach(file => {
                if (!folderStats[file.folder]) {
                    folderStats[file.folder] = { total: 0, completed: 0 };
                }
                folderStats[file.folder].total++;
                if (file.completed) {
                    folderStats[file.folder].completed++;
                }
            });
            
            const totalProgress = document.getElementById('totalProgress');
            const folderProgress = document.getElementById('folderProgress');
            
            totalProgress.textContent = `${completionPercent}% vollständig (${completedFiles}/${totalFiles})`;
            totalProgress.className = 'progress-stat';
            if (completionPercent >= 80) {
                totalProgress.classList.add('good');
            } else if (completionPercent >= 40) {
                totalProgress.classList.add('warning');
            }
            
            const folderCount = Object.keys(folderStats).length;
            const completedFolders = Object.values(folderStats).filter(stat => 
                stat.total > 0 && (stat.completed / stat.total) >= 0.8
            ).length;
            
            folderProgress.textContent = `${completedFolders}/${folderCount} Ordner ≥80%`;
            folderProgress.className = 'progress-stat';
            if (folderCount > 0 && (completedFolders / folderCount) >= 0.6) {
                folderProgress.classList.add('good');
            } else if (folderCount > 0 && (completedFolders / folderCount) >= 0.3) {
                folderProgress.classList.add('warning');
            }
            
            // Update folder progress tooltip
            const folderDetails = Object.entries(folderStats)
                .map(([folder, stats]) => {
                    const percent = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
                    const folderName = folder.split('/').pop();
                    return `${folderName}: ${percent}% (${stats.completed}/${stats.total})`;
                })
                .join('\n');
            
            folderProgress.title = `Ordner-Fortschritt:\n${folderDetails}`;
        }

        // Auto-resize text inputs based on content (HEIGHT not width)
        function autoResizeInput(input) {
            if (!input) return;
            
            // Reset height to auto to get the correct scroll height
            input.style.height = 'auto';
            
            // Calculate needed height
            const minHeight = 36; // Minimum height in pixels
            const newHeight = Math.max(minHeight, input.scrollHeight);
            
            // Set the new height
            input.style.height = newHeight + 'px';
            
            // Sync height with partner input in the same row
            syncRowHeights(input);
        }

        // Sync heights of EN and DE inputs in the same row
        function syncRowHeights(changedInput) {
            const row = changedInput.closest('tr');
            if (!row) return;
            
            const enInput = row.querySelector('td:nth-child(7) .text-input');
            const deInput = row.querySelector('td:nth-child(8) .text-input');
            
            if (!enInput || !deInput) return;
            
            // Get the maximum height needed
            enInput.style.height = 'auto';
            deInput.style.height = 'auto';
            
            const enHeight = Math.max(36, enInput.scrollHeight);
            const deHeight = Math.max(36, deInput.scrollHeight);
            const maxHeight = Math.max(enHeight, deHeight);
            
            // Set both inputs to the same height
            enInput.style.height = maxHeight + 'px';
            deInput.style.height = maxHeight + 'px';
        }

        // Auto-resize all text inputs in table
        function autoResizeAllInputs() {
            // Process all rows to sync heights
            document.querySelectorAll('#fileTableBody tr').forEach(row => {
                const enInput = row.querySelector('td:nth-child(7) .text-input');
                const deInput = row.querySelector('td:nth-child(8) .text-input');
                
                if (enInput && deInput) {
                    // Reset heights
                    enInput.style.height = 'auto';
                    deInput.style.height = 'auto';
                    
                    // Calculate max height needed
                    const enHeight = Math.max(36, enInput.scrollHeight);
                    const deHeight = Math.max(36, deInput.scrollHeight);
                    const maxHeight = Math.max(enHeight, deHeight);
                    
                    // Set both to same height
                    enInput.style.height = maxHeight + 'px';
                    deInput.style.height = maxHeight + 'px';
                }
            });
        }
		
// Completion Toggle All - für den orangen Haken
function toggleCompletionAll() {
    const completionCheckboxes = document.querySelectorAll('.completion-checkbox');
    
    // Prüfe ob alle bereits markiert sind
    const allCompleted = Array.from(completionCheckboxes).every(cb => cb.checked);
    
    // Wenn alle markiert sind, alle abwählen, sonst alle auswählen
    const newState = !allCompleted;
    
    completionCheckboxes.forEach(checkbox => {
        if (checkbox.checked !== newState) {
            checkbox.checked = newState;
            
            // Trigger das change event für jede Checkbox
            const fileId = parseFloat(checkbox.closest('tr').dataset.id);
            const file = files.find(f => f.id === fileId);
            if (file) {
                file.completed = newState;
                
                // Update row appearance
                const row = checkbox.closest('tr');
                if (newState) {
                    row.classList.add('completed');
                } else {
                    row.classList.remove('completed');
                }
            }
        }
    });
    
    isDirty = true;
    updateProgressStats();
    renderProjects(); // HINZUFÜGEN für live Update
    
    const count = Array.from(completionCheckboxes).filter(cb => cb.checked).length;
    updateStatus(newState ? 
        `Alle ${count} Dateien als fertig markiert` : 
        'Alle Dateien als unfertig markiert'
    );
}

        // Selection
        function toggleFileSelection(fileId) {
            const file = files.find(f => f.id === fileId);
            if (file) {
                file.selected = !file.selected;
                isDirty = true;
                updateCounts();
            }
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll').checked;
            files.forEach(file => file.selected = selectAll);
            isDirty = true;
            renderFileTable();
        }

function deleteFile(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;
    
    files = files.filter(f => f.id !== fileId);
    
    // Update display order
    displayOrder = displayOrder.filter(item => item.file.id !== fileId);
    
    isDirty = true;
    renderFileTable();
    renderProjects(); // HINZUGEFÜGT für live Update
    updateStatus(`${file.filename} entfernt`);
    updateProgressStats();
}

        // Row number manipulation
        function changeRowNumber(fileId, currentPosition) {
            const file = files.find(f => f.id === fileId);
            if (!file) return;
            
            const maxPosition = files.length;
            const newPositionStr = prompt(
                `Position ändern für: ${file.filename}\n\n` +
                `Aktuelle Position: ${currentPosition}\n` +
                `Verfügbare Positionen: 1 bis ${maxPosition}\n\n` +
                `Neue Position eingeben:`,
                currentPosition.toString()
            );
            
            if (!newPositionStr) return; // User cancelled
            
            const newPosition = parseInt(newPositionStr);
            
            // Validate input
            if (isNaN(newPosition) || newPosition < 1 || newPosition > maxPosition) {
                alert(`Ungültige Position!\n\nBitte eine Zahl zwischen 1 und ${maxPosition} eingeben.`);
                return;
            }
            
            if (newPosition === currentPosition) {
                return; // No change needed
            }
            
            // Remove file from current position
            const currentIndex = currentPosition - 1;
            const targetIndex = newPosition - 1;
            
            // Remove the file from the array
            const [movedFile] = files.splice(currentIndex, 1);
            
            // Insert at new position
            files.splice(targetIndex, 0, movedFile);
            
            // Reset display order to reflect new order
            displayOrder = files.map((file, index) => ({ file, originalIndex: index }));
            
            isDirty = true;
            renderFileTable();
            
            // Show success message
            if (newPosition < currentPosition) {
                updateStatus(`${file.filename} von Position ${currentPosition} nach ${newPosition} verschoben (nach oben)`);
            } else {
                updateStatus(`${file.filename} von Position ${currentPosition} nach ${newPosition} verschoben (nach unten)`);
            }
            
            // Highlight the moved row briefly
            setTimeout(() => {
                const newRow = document.querySelector(`tr[data-id="${fileId}"]`);
                if (newRow) {
                    newRow.style.background = '#ff6b1a';
                    newRow.style.transition = 'background 0.3s';
                    setTimeout(() => {
                        newRow.style.background = '';
                    }, 1000);
                }
            }, 100);
        }

// =========================== PLAYAUDIO START ===========================
// Audio playback with dynamic path resolution from database
function playAudio(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;
    
    console.log(`[PLAYAUDIO] ====== Playing: ${file.filename} ======`);
    console.log(`[PLAYAUDIO] File folder: ${file.folder}`);
    
    // Nutze die neue Hilfsfunktion
    const audioResult = findAudioInFilePathCache(file.filename, file.folder);
    
    if (!audioResult) {
        console.log(`[PLAYAUDIO] Audio not found, triggering auto-scan...`);
        
        const scanResult = checkAndAutoScan([file], 'Audio-Wiedergabe');
        if (scanResult === true) {
            updateStatus('Audio-Wiedergabe: Warte auf Ordner-Scan...');
            return;
        } else if (scanResult === false) {
            return;
        }
        
        updateStatus(`Audio nicht verfügbar: ${file.filename}`);
        return;
    }
    
    console.log(`[PLAYAUDIO] Audio found: ${audioResult.resolvedPath}`);
    
    // Audio abspielen
    const audio = document.getElementById('audioPlayer');
    const playBtns = document.querySelectorAll('.play-btn');
    
    // Reset all buttons
    playBtns.forEach(btn => {
        btn.classList.remove('playing');
        btn.textContent = '▶';
    });
    
    const playBtn = document.querySelector(`tr[data-id="${fileId}"] .play-btn`);
    
    // Stop current playback
    if (currentlyPlaying === fileId) {
        audio.pause();
        currentlyPlaying = null;
        return;
    }
    
    // Play from cached File object
    const blob = new Blob([audioResult.audioFile], { type: audioResult.audioFile.type });
    const url = URL.createObjectURL(blob);
    
    audio.src = url;
    audio.play().then(() => {
        if (playBtn) {
            playBtn.classList.add('playing');
            playBtn.textContent = '⏸';
        }
        currentlyPlaying = fileId;
        
        audio.onended = () => {
            URL.revokeObjectURL(url);
            if (playBtn) {
                playBtn.classList.remove('playing');
                playBtn.textContent = '▶';
            }
            currentlyPlaying = null;
        };
    }).catch(err => {
        console.error('[PLAYAUDIO] Playback failed:', err);
        updateStatus(`Fehler beim Abspielen: ${file.filename}`);
        URL.revokeObjectURL(url);
    });
}
// =========================== PLAYAUDIO END ===========================

// =========================== PLAYDEAUDIO START ======================
// Spiele die vorhandene DE-Datei ab
async function playDeAudio(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;

    const relPath = `${file.folder}/${file.filename}`;

    if (!deAudioCache[relPath]) {
        try {
            let handle = deOrdnerHandle;
            const parts = file.folder.split('/');
            for (const part of parts) {
                if (part) {
                    handle = await handle.getDirectoryHandle(part);
                }
            }
            const fh = await handle.getFileHandle(file.filename);
            deAudioCache[relPath] = await fh.getFile();
        } catch (e) {
            updateStatus('DE-Datei nicht gefunden');
            return;
        }
    }

    const audio = document.getElementById('audioPlayer');
    const playBtns = document.querySelectorAll('.de-play-btn');
    playBtns.forEach(btn => { btn.classList.remove('playing'); btn.textContent = '▶'; });

    const playBtn = document.querySelector(`tr[data-id="${fileId}"] .de-play-btn`);

    if (currentlyPlaying === `de-${fileId}`) {
        audio.pause();
        currentlyPlaying = null;
        return;
    }

    const url = URL.createObjectURL(deAudioCache[relPath]);
    audio.src = url;
    audio.play().then(() => {
        if (playBtn) { playBtn.classList.add('playing'); playBtn.textContent = '⏸'; }
        currentlyPlaying = `de-${fileId}`;
        audio.onended = () => {
            URL.revokeObjectURL(url);
            if (playBtn) { playBtn.classList.remove('playing'); playBtn.textContent = '▶'; }
            currentlyPlaying = null;
        };
    }).catch(err => {
        console.error('DE-Playback fehlgeschlagen', err);
        updateStatus('Fehler beim Abspielen der DE-Datei');
        URL.revokeObjectURL(url);
    });
}
// =========================== PLAYDEAUDIO END ========================

// Bereinigung: Entferne fullPath aus allen Projekten
function updateAllFilePaths() {
    if (!confirm('Dies bereinigt alle Projekte und entfernt veraltete Pfade.\nDie Pfade werden dynamisch aus der Datenbank geladen.\n\nFortfahren?')) {
        return;
    }
    
    let totalUpdated = 0;
    let totalProjects = 0;
    
    console.log('=== Projekt-Bereinigung: Entferne fullPath ===');
    
    projects.forEach(project => {
        if (!project.files || project.files.length === 0) return;
        
        totalProjects++;
        let projectUpdated = 0;
        
        project.files.forEach(file => {
            if (file.fullPath) {
                console.log(`Bereinige ${project.name}: ${file.filename} - entferne fullPath`);
                delete file.fullPath;
                projectUpdated++;
                totalUpdated++;
            }
        });
        
        if (projectUpdated > 0) {
            console.log(`📁 Projekt "${project.name}": ${projectUpdated} Dateien bereinigt`);
        }
    });
    
    if (totalUpdated > 0) {
        // Speichere alle bereinigten Projekte
        saveProjects();
        console.log(`🎯 Gesamt: ${totalUpdated} Dateien in ${totalProjects} Projekten bereinigt`);
        
        // Aktualisiere das aktuelle Projekt
        if (currentProject) {
            const updatedProject = projects.find(p => p.id === currentProject.id);
            if (updatedProject) {
                files = updatedProject.files || [];
                renderFileTable();
                updateProgressStats();
            }
        }
        
        updateStatus(`📁 Projekt-Bereinigung: ${totalUpdated} fullPath Einträge entfernt`);
        
        alert(`✅ Projekt-Bereinigung erfolgreich!\n\n` +
              `📊 Statistik:\n` +
              `• ${totalUpdated} veraltete Pfade entfernt\n` +
              `• ${totalProjects} Projekte bereinigt\n` +
              `• Pfade werden jetzt dynamisch geladen\n\n` +
              `🎯 Alle Audio-Funktionen sollten wieder funktionieren!`);
    } else {
        alert('✅ Alle Projekte sind bereits bereinigt!\n\nKeine veralteten Pfade gefunden.');
    }
    
    console.log('=== Projekt-Bereinigung abgeschlossen ===');
}

// Automatische Aktualisierung aller Projekte nach einem Ordner-Scan
function updateAllProjectsAfterScan() {
    let totalUpdated = 0;
    let totalProjects = 0;
    
    console.log('=== Automatische Projekt-Aktualisierung nach Scan ===');
    
    projects.forEach(project => {
        if (!project.files || project.files.length === 0) return;
        
        totalProjects++;
        let projectUpdated = 0;
        
        project.files.forEach(file => {
            // NEUE LOGIK: Prüfe immer auf bessere/normalisierte Pfade
            const currentPathExists = audioFileCache[file.fullPath];
            let shouldUpdate = false;
            let bestPath = null;
            
            if (filePathDatabase[file.filename]) {
                // Suche nach dem korrekten Pfad in der Datenbank
                const matchingPaths = filePathDatabase[file.filename].filter(pathInfo => {
                    // Exakte Ordner-Übereinstimmung
                    if (pathInfo.folder === file.folder) {
                        return true;
                    }
                    
                    // Normalisierte Ordner-Übereinstimmung
                    const normalizedFileFolder = normalizeFolderPath(file.folder);
                    const normalizedDbFolder = normalizeFolderPath(pathInfo.folder);
                    return normalizedFileFolder === normalizedDbFolder;
                });
                
                if (matchingPaths.length > 0) {
                    // Finde den besten Pfad (kürzester normalisierter Pfad hat Vorrang)
                    bestPath = matchingPaths.reduce((best, current) => {
                        const bestNormalized = normalizeFolderPath(best.folder);
                        const currentNormalized = normalizeFolderPath(current.folder);
                        
                        // Bevorzuge kürzere, normalisierte Pfade (vo/alyx statt sounds/vo/alyx)
                        if (currentNormalized.length < bestNormalized.length) {
                            return current;
                        } else if (currentNormalized.length === bestNormalized.length) {
                            // Bei gleicher Länge, bevorzuge Pfade die mit "vo/" starten
                            if (currentNormalized.startsWith('vo/') && !bestNormalized.startsWith('vo/')) {
                                return current;
                            }
                        }
                        return best;
                    });
                    
                    // Aktualisiere wenn:
                    // 1. Aktueller Pfad existiert nicht ODER
                    // 2. Gefundener Pfad ist besser/normalisierter als der aktuelle
                    if (!currentPathExists || 
                        bestPath.folder !== file.folder || 
                        bestPath.fullPath !== file.fullPath) {
                        shouldUpdate = true;
                    }
                }
            }
            
            if (shouldUpdate && bestPath) {
                const oldFolder = file.folder;
                const oldPath = file.fullPath;
                
                // Aktualisiere den Dateipfad
                file.folder = bestPath.folder;
                file.fullPath = bestPath.fullPath;
                projectUpdated++;
                totalUpdated++;
                
                console.log(`✅ ${project.name}: ${file.filename}`);
                console.log(`   Ordner: ${oldFolder} -> ${bestPath.folder}`);
                console.log(`   Pfad: ${oldPath} -> ${bestPath.fullPath}`);
            }
        });
        
        if (projectUpdated > 0) {
            console.log(`📁 Projekt "${project.name}": ${projectUpdated} Dateien aktualisiert`);
        }
    });
    
    if (totalUpdated > 0) {
        // Speichere alle aktualisierten Projekte
        saveProjects();
        console.log(`🎯 Gesamt: ${totalUpdated} Dateien in ${totalProjects} Projekten aktualisiert`);
        
        // Aktualisiere das aktuelle Projekt falls betroffen
        if (currentProject) {
            const updatedProject = projects.find(p => p.id === currentProject.id);
            if (updatedProject) {
                files = updatedProject.files || [];
                renderFileTable();
                updateProgressStats();
            }
        }
        
        setTimeout(() => {
            updateStatus(`📁 Projekt-Sync: ${totalUpdated} Dateipfade automatisch aktualisiert`);
        }, 1000);
    } else {
        console.log('✅ Alle Projekt-Pfade sind bereits aktuell');
    }
    
    console.log('=== Projekt-Aktualisierung abgeschlossen ===');
}


// =========================== GETGLOBALCOMPLETIONSTATUS START ===========================
function getGlobalCompletionStatus() {
    const completionMap         = new Map(); // fileKey -> true
    const projectCompletionMap  = new Map(); // fileKey -> [Projekt-Namen]

    projects.forEach(project => {
        (project.files || []).forEach(f => {
            const fileKey = `${f.folder}/${f.filename}`;

            if (ignoredFiles[fileKey]) return;   // Ignorierte komplett überspringen

            completionMap.set(fileKey, true);

            if (!projectCompletionMap.has(fileKey)) {
                projectCompletionMap.set(fileKey, []);
            }
            projectCompletionMap.get(fileKey).push(project.name);
        });
    });

    return { completionMap, projectCompletionMap };
}
// =========================== GETGLOBALCOMPLETIONSTATUS END ===========================


// =========================== CALCFOLDERCOMPLETIONSTATS START ===========================
function calculateFolderCompletionStats() {
    const { completionMap } = getGlobalCompletionStatus();
    const folderStats = new Map();

    // WICHTIG: Wir müssen jeden Ordner einzeln behandeln
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        // Jeder Pfad ist ein separater Eintrag!
        paths.forEach(pathInfo => {
            const folder  = pathInfo.folder;
            const fileKey = `${folder}/${filename}`;

            if (ignoredFiles[fileKey]) return;   // hier rausfiltern

            if (!folderStats.has(folder)) {
                folderStats.set(folder, { 
                    total: 0, 
                    completed: 0, 
                    files: [],
                    folderName: folder // Speichere den vollen Ordnernamen
                });
            }

            const stats = folderStats.get(folder);
            stats.total++;

            const done = completionMap.has(fileKey);
            stats.files.push({ 
                filename, 
                fileKey, 
                completed: done,
                folder: folder // Speichere auch hier den Ordner
            });

            if (done) stats.completed++;
        });
    });

    folderStats.forEach((stats, folder) => {
        stats.percentage = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
        stats.isComplete = stats.percentage === 100;
    });

    return folderStats;
}
// =========================== CALCFOLDERCOMPLETIONSTATS END ===========================


        // Auto-scan system for missing permissions
        function checkAndAutoScan(requiredFiles = [], functionName = 'Funktion') {
            let missingFiles = [];
            
            // Check if specific files are accessible
            if (requiredFiles.length > 0) {
                missingFiles = requiredFiles.filter(file => !audioFileCache[file.fullPath]);
            } else {
                // General check - if we have files but no audio cache
                missingFiles = files.filter(f => f.selected && !audioFileCache[f.fullPath]);
            }
            
            if (missingFiles.length > 0) {
                console.log(`Auto-Scan ausgelöst von ${functionName}: ${missingFiles.length} Dateien ohne Berechtigung`);

                if (!projektOrdnerHandle) {
                    const chooseProject = confirm(
                        `🔒 Dateiberechtigungen erforderlich\n\n` +
                        `${functionName} benötigt Zugriff auf Audio-Dateien.\n` +
                        `Es wurde noch kein Projektordner gewählt.\n\n` +
                        `✅ JA - Projektordner wählen\n` +
                        `❌ NEIN - Abbrechen\n\n` +
                        `Projektordner wählen?`
                    );

                    if (chooseProject) {
                        updateStatus('Projektordner wird geöffnet...');
                        waehleProjektOrdner();
                        return true; // Scan started via project folder
                    } else {
                        updateStatus(`${functionName}: Abgebrochen - Kein Projektordner`);
                        return false; // User cancelled
                    }
                }

                // Show user-friendly message
                const shouldScan = confirm(
                    `🔒 Dateiberechtigungen erforderlich\n\n` +
                    `${functionName} benötigt Zugriff auf Audio-Dateien.\n` +
                    `${missingFiles.length} von ${requiredFiles.length > 0 ? requiredFiles.length : files.length} Dateien sind nicht verfügbar.\n\n` +
                    `Grund: Browser-Berechtigungen sind abgelaufen oder Dateien wurden nicht gescannt.\n\n` +
                    `✅ JA - Ordner jetzt scannen (automatisch)\n` +
                    `❌ NEIN - Abbrechen\n\n` +
                    `Ordner-Scan starten?`
                );

                if (shouldScan) {
                    updateStatus(`${functionName}: Starte automatischen Ordner-Scan...`);
                    setTimeout(() => {
                        document.getElementById('folderPicker').click();
                    }, 500);
                    return true; // Scan started
                } else {
                    updateStatus(`${functionName}: Abgebrochen - Keine Berechtigungen`);
                    return false; // User cancelled
                }
            }
            
            return null; // No scan needed
        }

        // Enhanced file access check with auto-scan
        function checkFileAccessWithAutoScan(functionName = 'Funktion') {
            const stats = checkFileAccess();
            
            if (stats.selectedFiles === 0) {
                alert(`ℹ️ ${functionName}\n\nKeine Dateien ausgewählt.\n\nBitte wählen Sie erst Dateien aus.`);
                return false;
            }
            
            if (stats.inaccessibleFiles > 0) {
                return checkAndAutoScan(files.filter(f => f.selected), functionName) === null;
            }
            
            return true; // All good
        }

        function closeFolderBrowser() {
            document.getElementById('folderBrowserDialog').style.display = 'none';
        }



// =========================== SHOWFOLDERGRID WITH DELETE START ===========================
function showFolderGrid() {
    const folderGrid = document.getElementById('folderGrid');
    const folderFilesView = document.getElementById('folderFilesView');
    const folderBackBtn = document.getElementById('folderBackBtn');
    const title = document.getElementById('folderBrowserTitle');
    const description = document.getElementById('folderBrowserDescription');
    
    // Show grid, hide files view
    folderGrid.style.display = 'grid';
    folderFilesView.style.display = 'none';
    folderBackBtn.style.display = 'none';
    
    title.textContent = '📁 Ordner durchsuchen';
    
    // Calculate global completion stats
    const folderStats = calculateFolderCompletionStats();
    const totalFolders = folderStats.size;
    const completedFolders = Array.from(folderStats.values()).filter(s => s.isComplete).length;
    const totalFiles = Array.from(folderStats.values()).reduce((sum, s) => sum + s.total, 0);
    const completedFiles = Array.from(folderStats.values()).reduce((sum, s) => sum + s.completed, 0);
    const overallPercentage = totalFiles > 0 ? Math.round((completedFiles / totalFiles) * 100) : 0;
    
    const { en: globalEN, de: globalDE, both: globalBoth, total: globalTotal } = calculateGlobalTextStats();
    
    // Update description with stats and cleanup button
    description.innerHTML = `
        <div class="folder-stats">
            <h4>📊 Globale Übersetzungsstatistiken</h4>
            <div class="folder-stats-grid">
                <div class="folder-stat-item">
                    <div class="folder-stat-number ${overallPercentage === 100 ? 'complete' : overallPercentage > 0 ? 'partial' : 'none'}">
                        ${overallPercentage}%
                    </div>
                    <div class="folder-stat-label">Gesamt-Fortschritt</div>
                </div>
                <div class="folder-stat-item">
                    <div class="folder-stat-number ${completedFiles > 0 ? 'complete' : 'none'}">
                        ${completedFiles}/${totalFiles}
                    </div>
                    <div class="folder-stat-label">Dateien übersetzt</div>
                </div>
                <div class="folder-stat-item">
                    <div class="folder-stat-number ${completedFolders > 0 ? 'complete' : 'none'}">
                        ${completedFolders}/${totalFolders}
                    </div>
                    <div class="folder-stat-label">Ordner komplett</div>
                </div>
                <div class="folder-stat-item">
                    <div class="folder-stat-number ${globalBoth === globalTotal && globalTotal > 0 ? 'complete' : globalBoth > 0 ? 'partial' : 'none'}" id="globalTextStatsValue">
                        ${globalEN} / ${globalDE} / ${globalBoth} / ${globalTotal}
                    </div>
                    <div class="folder-stat-label">EN / DE / BEIDE / ∑</div>
                </div>
            </div>
        </div>
        <div style="display: flex; gap: 10px; margin: 15px 0; align-items: center;">
            <p style="color: #999; flex: 1;">Durchsuchen Sie alle verfügbaren Ordner. Grüne Ordner sind vollständig übersetzt.</p>
            <button class="btn btn-secondary" onclick="cleanupIncorrectFolderNames()" title="Bereinigt falsche Ordnernamen in der Datenbank">
                🧹 Ordnernamen bereinigen
            </button>
        </div>
    `;
    
    // Get UNIQUE folders from filePathDatabase
    const uniqueFolders = new Map();
    
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        paths.forEach(pathInfo => {
            const folder = pathInfo.folder;
            
            if (!uniqueFolders.has(folder)) {
                uniqueFolders.set(folder, {
                    name: folder,
                    files: []
                });
            }
            
            uniqueFolders.get(folder).files.push({
                filename: filename,
                fullPath: pathInfo.fullPath,
                folder: folder
            });
        });
    });
    
    // FALLBACK: If filePathDatabase is empty, use current project files and textDatabase
    if (uniqueFolders.size === 0) {
        console.log('filePathDatabase leer, verwende Fallback mit aktuellen Projektdateien und textDatabase');
        
        // Check current project files
        files.forEach(file => {
            if (!uniqueFolders.has(file.folder)) {
                uniqueFolders.set(file.folder, {
                    name: file.folder,
                    files: []
                });
            }
            uniqueFolders.get(file.folder).files.push({
                filename: file.filename,
                fullPath: file.fullPath,
                folder: file.folder
            });
        });
        
        // Also check textDatabase for additional files
        Object.entries(textDatabase).forEach(([fileKey, texts]) => {
            const parts = fileKey.split('/');
            const filename = parts.pop();
            const folder = parts.join('/');
            
            if (folder && filename) {
                if (!uniqueFolders.has(folder)) {
                    uniqueFolders.set(folder, {
                        name: folder,
                        files: []
                    });
                }
                
                // Only add if not already present
                const folderData = uniqueFolders.get(folder);
                if (!folderData.files.find(f => f.filename === filename)) {
                    folderData.files.push({
                        filename: filename,
                        fullPath: `${folder}/${filename}`,
                        folder: folder
                    });
                }
            }
        });
    }
    
    // Check if we still have no folders and trigger auto-scan
    if (uniqueFolders.size === 0) {
        // Auto-scan for empty folder browser
        console.log('Ordner-Browser leer, starte automatischen Scan...');
        setTimeout(() => {
            closeFolderBrowser();
            updateStatus('Ordner-Browser: Starte automatischen Ordner-Scan...');
            document.getElementById('folderPicker').click();
        }, 1000);
        
        folderGrid.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #999;">
                <div style="font-size: 48px; margin-bottom: 20px;">🔄</div>
                <h3 style="color: #ff6b1a; margin-bottom: 10px;">Automatischer Ordner-Scan</h3>
                <p style="margin-bottom: 20px;">
                    Keine Ordner gefunden. Starte automatischen Scan...<br>
                    Bitte wählen Sie einen Ordner mit Audio-Dateien aus.
                </p>
                <div style="animation: pulse-auto-scan 2s infinite;">📁 Ordner-Dialog wird geöffnet...</div>
            </div>
        `;
        return;
    }
    
    // Convert Map to Array and sort
    const sortedFolders = Array.from(uniqueFolders.values()).sort((a, b) => a.name.localeCompare(b.name));
    
    // Render folder cards with completion stats and delete button
    folderGrid.innerHTML = sortedFolders.map(folder => {
        const lastFolderName = folder.name.split('/').pop() || folder.name;
        const folderClass = lastFolderName.toLowerCase().replace(/[^a-z]/g, '');
        
        // Get completion stats for this folder
        const stats = folderStats.get(folder.name) || { total: folder.files.length, completed: 0, percentage: 0, isComplete: false };
        
        // Get custom icon and color or default
        const customization = folderCustomizations[folder.name] || {};
        let folderIcon = customization.icon;
        let folderColor = customization.color || '#333';
        
        // Get default folder icon if no custom one set
        if (!folderIcon) {
            if (lastFolderName.toLowerCase().includes('gman')) folderIcon = '👤';
            else if (lastFolderName.toLowerCase().includes('alyx')) folderIcon = '👩';
            else if (lastFolderName.toLowerCase().includes('russell')) folderIcon = '👨‍🔬';
            else if (lastFolderName.toLowerCase().includes('eli')) folderIcon = '👨‍🦳';
            else if (lastFolderName.toLowerCase().includes('vortigaunt')) folderIcon = '👽';
            else if (lastFolderName.toLowerCase().includes('combine')) folderIcon = '🤖';
            else if (lastFolderName.toLowerCase().includes('jeff')) folderIcon = '🧟';
            else if (lastFolderName.toLowerCase().includes('zombie')) folderIcon = '🧟‍♂️';
            else if (lastFolderName.toLowerCase().includes('charger')) folderIcon = '⚡';
            else if (lastFolderName.toLowerCase().includes('officer')) folderIcon = '👮';
            else folderIcon = '📁';
        }
        
        // Determine completion status styling
        let completionClass = '';
        let completionColor = '';
        if (stats.isComplete) {
            completionClass = 'completed';
            completionColor = '#4caf50';
        } else if (stats.percentage > 0) {
            completionColor = '#ff9800';
        } else {
            completionColor = '#666';
        }
        
        return `
            <div class="folder-card ${completionClass}" style="background: ${folderColor}; position: relative;">
                <!-- Anpassungs-Button oben links -->
                <button class="folder-customize-btn"
                        onclick="event.stopPropagation(); showFolderCustomization('${folder.name}')"
                        title="Ordner anpassen"
                        style="position: absolute; top: 8px; left: 8px;">
                    ⚙️
                </button>
                <!-- Lösch-Button oben rechts -->
                <button class="folder-delete-btn"
                        onclick="event.stopPropagation(); deleteFolderFromDatabase('${folder.name}')"
                        title="Ordner aus Datenbank löschen"
                        style="position: absolute; top: 8px; right: 8px; background: rgba(244,67,54,0.8); border: none; color: white; width: 24px; height: 24px; border-radius: 12px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;"
                        onmouseover="this.style.background='#f44336'"
                        onmouseout="this.style.background='rgba(244,67,54,0.8)'">×</button>
                
                <!-- Ordner-Inhalt (klickbar) -->
                <div onclick="showFolderFiles('${folder.name}')" style="cursor: pointer; padding: 15px;">
                    <div class="folder-card-icon">${folderIcon}</div>
                    <div class="folder-card-name">${lastFolderName}</div>
                    <div class="folder-card-count">${folder.files.length} Dateien</div>
                    <div class="folder-card-completion ${stats.isComplete ? 'complete' : stats.percentage > 0 ? 'partial' : 'none'}" style="color: ${completionColor};">
                        ${stats.percentage}% übersetzt
                        ${stats.isComplete ? ' ✅' : stats.percentage > 0 ? ' 🔄' : ' ⏳'}
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add debug info for development
    console.log(`Ordner-Browser: ${sortedFolders.length} Ordner gefunden`);
    console.log('Completion Stats:', Object.fromEntries(folderStats));
    console.log('Gefundene Ordner:', sortedFolders.map(f => f.name));
    console.log(`[GLOBAL STATS] EN: ${globalEN}, DE: ${globalDE}, Both: ${globalBoth}, Total: ${globalTotal}`);
}
// =========================== SHOWFOLDERGRID WITH DELETE END ===========================

// =========================== CLEANUPINCORRECTFOLDERNAMES START ===========================
function cleanupIncorrectFolderNames() {
    if (!confirm('Dies bereinigt die Datenbank von Einträgen mit falschen Ordnernamen.\n\nNur Dateien, die wirklich in dem angegebenen Ordner liegen, bleiben erhalten.\n\nFortfahren?')) {
        return;
    }
    
    let totalChecked = 0;
    let totalCorrected = 0;
    let totalRemoved = 0;
    
    console.log('=== Bereinigung falscher Ordnernamen ===');
    
    // Sammle alle gescannten Pfade für Vergleich
    const realPaths = new Set();
    Object.values(audioFileCache).forEach(fileObj => {
        if (fileObj && fileObj.webkitRelativePath) {
            realPaths.add(fileObj.webkitRelativePath);
        }
    });
    
    console.log(`Gefundene echte Pfade: ${realPaths.size}`);
    
    // Prüfe jeden Datenbank-Eintrag
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        const correctPaths = [];
        
        paths.forEach(pathInfo => {
            totalChecked++;
            
            // Prüfe ob der angegebene Pfad wirklich existiert
            const realPathExists = realPaths.has(pathInfo.fullPath);
            
            if (realPathExists) {
                // Pfad ist korrekt - behalten
                correctPaths.push(pathInfo);
                console.log(`✅ Korrekt: ${filename} in ${pathInfo.folder}`);
            } else {
                // Pfad existiert nicht - versuche korrekten Pfad zu finden
                let foundCorrectPath = false;
                
                for (const realPath of realPaths) {
                    if (realPath.endsWith('/' + filename)) {
                        // Finde den korrekten Ordner für diese Datei
                        const parts = realPath.split('/');
                        const correctFolder = extractRelevantFolder(parts.slice(0, -1), realPath);
                        
                        // Prüfe ob wir schon einen Eintrag für diesen Ordner haben
                        const alreadyHasCorrectFolder = correctPaths.some(p => p.folder === correctFolder);
                        
                        if (!alreadyHasCorrectFolder) {
                            // Finde das entsprechende File-Objekt
                            const correctFileObj = Object.values(audioFileCache).find(
                                fileObj => fileObj.webkitRelativePath === realPath
                            );
                            
                            if (correctFileObj) {
                                correctPaths.push({
                                    folder: correctFolder,
                                    fullPath: realPath,
                                    fileObject: correctFileObj
                                });
                                
                                console.log(`🔧 Korrigiert: ${filename} von "${pathInfo.folder}" zu "${correctFolder}"`);
                                totalCorrected++;
                                foundCorrectPath = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!foundCorrectPath) {
                    console.log(`❌ Entfernt: ${filename} in "${pathInfo.folder}" (Pfad existiert nicht: ${pathInfo.fullPath})`);
                    totalRemoved++;
                    
                    // Entferne aus Audio-Cache falls vorhanden
                    if (audioFileCache[pathInfo.fullPath]) {
                        delete audioFileCache[pathInfo.fullPath];
                    }
                }
            }
        });
        
        // Aktualisiere Datenbank mit korrigierten Pfaden
        if (correctPaths.length > 0) {
            filePathDatabase[filename] = correctPaths;
        } else {
            // Keine korrekten Pfade gefunden - entferne Datei komplett
            delete filePathDatabase[filename];
            console.log(`🗑️ Datei komplett entfernt: ${filename} (keine gültigen Pfade)`);
        }
    });
    
    // Speichere bereinigte Datenbank
    saveFilePathDatabase();
    
    // Aktualisiere Projekte
    updateAllProjectsAfterScan();
    
    const results = `✅ Ordnernamen-Bereinigung abgeschlossen!\n\n` +
        `📊 Statistik:\n` +
        `• ${totalChecked} Einträge geprüft\n` +
        `• ${totalCorrected} Ordnernamen korrigiert\n` +
        `• ${totalRemoved} falsche Einträge entfernt\n` +
        `• ${Object.keys(filePathDatabase).length} Dateien verbleiben\n\n` +
        `🎯 Alle Einträge haben jetzt korrekte Ordnernamen!`;
    
    updateStatus(`Ordnernamen bereinigt: ${totalCorrected} korrigiert, ${totalRemoved} entfernt`);
    
    // Aktualisiere aktuelle Ansicht falls Ordner-Browser offen
    const folderBrowserOpen = document.getElementById('folderBrowserDialog').style.display === 'flex';
    if (folderBrowserOpen) {
        showFolderGrid();
    }
    
    alert(results);
    console.log('=== Bereinigung abgeschlossen ===');
}
// =========================== CLEANUPINCORRECTFOLDERNAMES END ===========================

// =========================== GETBROWSERDEBUGPATHINFO START ===========================
// Debug-Pfad-Information für Ordner-Browser
function getBrowserDebugPathInfo(file) {
    if (!filePathDatabase[file.filename]) {
        return '❌ Nicht in DB';
    }
    
    const dbPaths = filePathDatabase[file.filename];
    
    // Suche passende Pfade für diese spezifische Datei
    const exactMatches = dbPaths.filter(pathInfo => pathInfo.folder === file.folder);
    
    if (exactMatches.length > 0) {
        const bestPath = exactMatches[0];
        const isAudioAvailable = !!audioFileCache[bestPath.fullPath];
        const status = isAudioAvailable ? '✅' : '❌';
        return `${status} VERFÜGBAR<br><small style="word-break: break-all;">${bestPath.fullPath}</small>`;
    }
    
    // Normalisierte Suche
    const normalizedMatches = dbPaths.filter(pathInfo => {
        const normalizedFileFolder = normalizeFolderPath(file.folder);
        const normalizedDbFolder = normalizeFolderPath(pathInfo.folder);
        return normalizedFileFolder === normalizedDbFolder;
    });
    
    if (normalizedMatches.length > 0) {
        const bestPath = normalizedMatches[0];
        const isAudioAvailable = !!audioFileCache[bestPath.fullPath];
        const status = isAudioAvailable ? '⚠️' : '❌';
        return `${status} NORMALISIERT<br><small style="word-break: break-all;">Browser: ${file.folder}<br>DB: ${bestPath.folder}</small>`;
    }
    
    // Keine Matches - zeige verfügbare Ordner
    const availableFolders = dbPaths.map(p => p.folder).slice(0, 2).join('<br>');
    const moreCount = dbPaths.length > 2 ? ` (+${dbPaths.length - 2} weitere)` : '';
    return `❌ KEINE MATCHES<br><small style="word-break: break-all;">Browser: ${file.folder}<br>DB hat:<br>${availableFolders}${moreCount}</small>`;
}
// =========================== GETBROWSERDEBUGPATHINFO END ===========================

// =========================== SHOWFOLDERFILES START ===========================
function showFolderFiles(folderName) {
    const folderGrid      = document.getElementById('folderGrid');
    const folderFilesView = document.getElementById('folderFilesView');
    const folderBackBtn   = document.getElementById('folderBackBtn');
    const title           = document.getElementById('folderBrowserTitle');
    const description     = document.getElementById('folderBrowserDescription');

    folderGrid.style.display      = 'none';
    folderFilesView.style.display = 'block';
    folderBackBtn.style.display   = 'block';

    const lastFolderName = folderName.split('/').pop() || folderName;
    const customization  = folderCustomizations[folderName] || {};
    const folderIcon     = customization.icon || '📁';

    const { completionMap, projectCompletionMap } = getGlobalCompletionStatus();
    const folderFiles = [];

    // --- aus Datenbank sammeln ---
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        paths.forEach(pathInfo => {
            if (pathInfo.folder !== folderName) return;

            const fileKey = `${pathInfo.folder}/${filename}`;
            const text    = textDatabase[fileKey] || {};

            folderFiles.push({
                filename,
                folder: pathInfo.folder,
                fullPath: pathInfo.fullPath,
                enText: text.en || '',
                deText: text.de || '',
                isCompleted: completionMap.has(fileKey),
                completedInProjects: projectCompletionMap.get(fileKey) || [],
                isIgnored: !!ignoredFiles[fileKey]
            });
        });
    });

    // --- Fallback aus Projekt ---
    if (folderFiles.length === 0) {
        files.filter(f => f.folder === folderName).forEach(f => {
            const fileKey = `${f.folder}/${f.filename}`;
            const text    = textDatabase[fileKey] || {};

            folderFiles.push({
                filename: f.filename,
                folder: f.folder,
                fullPath: f.fullPath,
                enText: text.en || '',
                deText: text.de || '',
                isCompleted: completionMap.has(fileKey),
                completedInProjects: projectCompletionMap.get(fileKey) || [],
                isIgnored: !!ignoredFiles[fileKey]
            });
        });
    }

    // --- Übersichts-Text ---
    const total     = folderFiles.length;
    const completed = folderFiles.filter(f => f.isCompleted).length;
    const ignored   = folderFiles.filter(f => f.isIgnored).length;

    title.innerHTML = `${folderIcon} ${lastFolderName} <button class="folder-customize-btn" onclick="showFolderCustomization('${folderName}')">⚙️</button>`;
    description.innerHTML = `✅ ${completed} übersetzt – 🚫 ${ignored} ignoriert – ⏳ ${total - completed - ignored} offen`;

    // --- Rendern mit Pfad-Anzeige ---
    folderFilesView.innerHTML = folderFiles.map(file => {
        const inProject = files.find(f => f.filename === file.filename && f.folder === file.folder);
        
        // Debug-Pfad-Information generieren
        const debugPathInfo = getBrowserDebugPathInfo(file);
        
        return `
            <div class="folder-file-item ${file.isCompleted ? 'completed' : ''} ${file.isIgnored ? 'ignored' : ''}">
                <div class="folder-file-info">
                    <div class="folder-file-name">
                        ${file.filename}
                        ${file.isCompleted ? `<span class="folder-file-badge done"  title="Übersetzt">✅ Übersetzt</span>` : ''}
                        ${file.isIgnored   ? `<span class="folder-file-badge skip">🚫 Ignoriert</span>`           : ''}
                    </div>
                    
                    <!-- Debug-Pfad-Anzeige -->
                    <div style="font-size: 10px; color: #666; margin: 4px 0; padding: 4px 8px; background: #1a1a1a; border-radius: 3px; border-left: 3px solid #333;">
                        <strong>🔍 Pfad:</strong> ${debugPathInfo}
                    </div>
                    
                    <div class="folder-file-texts">
                        <div class="folder-file-text">
                            <div class="folder-file-text-label">EN</div>
                            <div class="folder-file-text-content" title="${escapeHtml(file.enText)}">
                                ${file.enText || '(kein Text)'}
                            </div>
                        </div>
                        <div class="folder-file-text">
                            <div class="folder-file-text-label">DE</div>
                            <div class="folder-file-text-content" title="${escapeHtml(file.deText)}">
                                ${file.deText || '(kein Text)'}
                            </div>
                        </div>
                    </div>
                </div>

                <div class="folder-file-actions">
                    <button class="folder-file-play" onclick="playFolderBrowserAudio('${file.fullPath}', this)">▶</button>
                    <button class="folder-file-add" ${inProject ? 'disabled' : ''} 
                            onclick="addFileFromFolderBrowser('${file.filename}', '${file.folder}', '${file.fullPath}')">
                        ${inProject ? '✓ Bereits hinzugefügt' : '+ Hinzufügen'}
                    </button>
                    <button class="folder-file-ignore"
                            onclick="toggleSkipFile('${file.folder}', '${file.filename}')">
                        ${file.isIgnored ? '↩ Wieder aufnehmen' : '🚫 Ignorieren'}
                    </button>
                </div>
            </div>`;
    }).join('');
}
// =========================== SHOWFOLDERFILES END ===========================

// =========================== REFRESHGLOBAL START ===========================
function refreshGlobalStatsAndGrids() {
    // Aktuelle Statistiken der Ordner ermitteln
    const folderStats = calculateFolderCompletionStats();

    // Fortschrittsbalken neu berechnen
    updateProgressStats();

    // Grid nur neu zeichnen, falls es sichtbar ist
    if (document.getElementById('folderGrid').style.display !== 'none') {
        showFolderGrid();
    }
}
// =========================== REFRESHGLOBAL END ===========================



// =========================== DELETEFOLDERFROMBROWSER START ===========================
function deleteFolderFromDatabase(folderName) {
    // Doppelte Sicherheitsprüfung
    let hasTexts = false;
    let hasProjectFiles = false;
    
    // Prüfe auf Texte
    Object.entries(textDatabase).forEach(([fileKey, texts]) => {
        if (fileKey.startsWith(folderName + '/')) {
            if ((texts.en && texts.en.trim()) || (texts.de && texts.de.trim())) {
                hasTexts = true;
            }
        }
    });
    
    // Prüfe auf Projekt-Dateien
    projects.forEach(project => {
        if (project.files && project.files.some(file => file.folder === folderName)) {
            hasProjectFiles = true;
        }
    });
    
    const lastFolderName = folderName.split('/').pop() || folderName;
    
    // Warnung wenn Texte oder Projekte vorhanden
    if (hasTexts || hasProjectFiles) {
        const warnings = [];
        if (hasTexts) warnings.push('Übersetzungen (EN/DE Texte)');
        if (hasProjectFiles) warnings.push('Dateien in Projekten');
        
        const warningText = warnings.join(' und ');
        
        if (!confirm(`⚠️ WARNUNG: Ordner kann nicht sicher gelöscht werden!\n\nDer Ordner "${lastFolderName}" enthält:\n• ${warningText}\n\nDas Löschen würde diese Daten beschädigen.\n\n💡 Empfehlung:\n1. Entfernen Sie zuerst alle Dateien aus Ihren Projekten\n2. Löschen Sie die Übersetzungen manuell\n3. Versuchen Sie dann erneut\n\nTROTZDEM LÖSCHEN? (Nicht empfohlen)`)) {
            return;
        }
    }
    
    // Bestätigungsdialog
    const fileCount = Object.entries(filePathDatabase).reduce((count, [filename, paths]) => {
        return count + paths.filter(p => p.folder === folderName).length;
    }, 0);
    
    if (!confirm(`🗑️ Ordner endgültig löschen\n\nMöchten Sie den Ordner "${lastFolderName}" wirklich aus der Datenbank löschen?\n\nDies entfernt:\n• ${fileCount} Dateipfade\n• Audio-Cache-Einträge\n• Ordner-Anpassungen\n${hasTexts ? '• Alle Übersetzungen (EN/DE)\n' : ''}${hasProjectFiles ? '• Alle Dateien aus Projekten\n' : ''}\n⚠️ Die Aktion kann NICHT rückgängig gemacht werden!\n\nFortfahren?`)) {
        return;
    }
    
    let deletedFiles = 0;
    let deletedAudioCache = 0;
    let deletedTexts = 0;
    let removedFromProjects = 0;
    
    // 1. Lösche alle Dateien aus diesem Ordner aus filePathDatabase
    Object.keys(filePathDatabase).forEach(filename => {
        const originalLength = filePathDatabase[filename].length;
        filePathDatabase[filename] = filePathDatabase[filename].filter(pathInfo => 
            pathInfo.folder !== folderName
        );
        
        const deletedFromFile = originalLength - filePathDatabase[filename].length;
        deletedFiles += deletedFromFile;
        
        // Entferne leere Einträge
        if (filePathDatabase[filename].length === 0) {
            delete filePathDatabase[filename];
        }
    });
    
    // 2. Lösche aus audioFileCache
    Object.keys(audioFileCache).forEach(fullPath => {
        if (fullPath.includes(folderName)) {
            delete audioFileCache[fullPath];
            deletedAudioCache++;
        }
    });
    
    // 3. Lösche Texte aus textDatabase
    Object.keys(textDatabase).forEach(fileKey => {
        if (fileKey.startsWith(folderName + '/')) {
            delete textDatabase[fileKey];
            deletedTexts++;
        }
    });
    
    // 4. Lösche Ordner-Anpassungen
    const hadCustomization = !!folderCustomizations[folderName];
    if (folderCustomizations[folderName]) {
        delete folderCustomizations[folderName];
    }
    
    // 5. Entferne Ordner aus allen Projekten
    projects.forEach(project => {
        if (project.files) {
            const originalLength = project.files.length;
            project.files = project.files.filter(file => file.folder !== folderName);
            removedFromProjects += originalLength - project.files.length;
        }
    });
    
    // 6. Speichere alle Änderungen
    saveFilePathDatabase();
    saveTextDatabase();
    saveFolderCustomizations();
    
    if (removedFromProjects > 0) {
        saveProjects();
        
        // Aktualisiere aktuelles Projekt falls betroffen
        if (currentProject) {
            const updatedProject = projects.find(p => p.id === currentProject.id);
            if (updatedProject) {
                files = updatedProject.files || [];
                renderFileTable();
                updateProgressStats();
                renderProjects();
            }
        }
    }
    
    // Erfolgs-Nachricht
    const successMessage = `✅ Ordner "${lastFolderName}" erfolgreich gelöscht!\n\n` +
        `📊 Entfernt:\n` +
        `• ${deletedFiles} Dateipfade\n` +
        `• ${deletedAudioCache} Audio-Cache-Einträge\n` +
        `• ${deletedTexts} Übersetzungseinträge\n` +
        `• ${removedFromProjects} Dateien aus Projekten\n` +
        `${hadCustomization ? '• Ordner-Anpassungen\n' : ''}` +
        `\n🎯 Verbleibend:\n` +
        `• ${Object.keys(filePathDatabase).length} Dateien in Datenbank\n` +
        `• ${Object.keys(textDatabase).length} Übersetzungseinträge`;
    
    alert(successMessage);
    updateStatus(`Ordner "${lastFolderName}" vollständig aus Datenbank gelöscht`);
    
    // Zurück zur Ordner-Übersicht
    showFolderGrid();
    
    console.log(`[DELETE FOLDER] ${lastFolderName} erfolgreich gelöscht - ${deletedFiles} Dateien, ${deletedTexts} Texte, ${removedFromProjects} Projektdateien entfernt`);
}
// =========================== DELETEFOLDERFROMBROWSER END ===========================

        function playFolderBrowserAudio(fullPath, button) {
            // Check if file is accessible, auto-scan if needed
            const fakeFile = { fullPath: fullPath, filename: fullPath.split('/').pop() };
            const scanResult = checkAndAutoScan([fakeFile], 'Ordner-Browser Audio');
            if (scanResult === true) {
                // Scan started
                updateStatus('Ordner-Browser Audio: Warte auf Ordner-Scan...');
                return;
            } else if (scanResult === false) {
                // User cancelled
                return;
            }
            // scanResult === null means file is accessible, continue
            
            const audio = document.getElementById('audioPlayer');
            
            // Reset all play buttons in folder browser
            document.querySelectorAll('.folder-file-play').forEach(btn => {
                btn.textContent = '▶';
                btn.style.background = '#444';
            });
            
            // Stop current playback
            if (currentlyPlaying === fullPath) {
                audio.pause();
                currentlyPlaying = null;
                return;
            }
            
            // Try to play from cached File object
            if (audioFileCache[fullPath]) {
                const fileObject = audioFileCache[fullPath];
                const blob = new Blob([fileObject], { type: fileObject.type });
                const url = URL.createObjectURL(blob);
                
                audio.src = url;
                audio.play().then(() => {
                    button.textContent = '⏸';
                    button.style.background = '#ff6b1a';
                    currentlyPlaying = fullPath;
                    
                    audio.onended = () => {
                        URL.revokeObjectURL(url);
                        button.textContent = '▶';
                        button.style.background = '#444';
                        currentlyPlaying = null;
                    };
                }).catch(err => {
                    console.error('Playback failed:', err);
                    updateStatus(`Fehler beim Abspielen`);
                    URL.revokeObjectURL(url);
                });
            } else {
                // This should not happen after auto-scan check, but just in case
                updateStatus('Audio nicht verfügbar - Berechtigung fehlt');
            }
        }

function addFileFromFolderBrowser(filename, folder, fullPath) {
    if (files.find(f => f.filename === filename && f.folder === folder)) {
        updateStatus('Datei bereits im Projekt');
        return;
    }
    
    const fileKey = `${folder}/${filename}`;
    const newFile = {
        id: Date.now() + Math.random(),
        filename: filename,
        folder: folder,
        // fullPath wird NICHT mehr gespeichert - wird dynamisch geladen
        enText: textDatabase[fileKey]?.en || '',
        deText: textDatabase[fileKey]?.de || '',
        selected: true,
        completed: false
    };
    
    files.push(newFile);
    
    // Update display order for new file
    displayOrder.push({ file: newFile, originalIndex: files.length - 1 });
    
    isDirty = true;
    renderFileTable();
    renderProjects(); // HINZUGEFÜGT für live Update
    updateStatus(`${filename} zum Projekt hinzugefügt`);
    updateProgressStats();
    
    // Update the button in the folder browser
    const addButton = event.target;
    addButton.disabled = true;
    addButton.textContent = '✓ Bereits hinzugefügt';
}

        // Folder customization functions
        function showFolderCustomization(folderName) {
            const customization = folderCustomizations[folderName] || {};
            const lastFolderName = folderName.split('/').pop() || folderName;
            
            // Get current values or defaults
            let currentIcon = customization.icon;
            let currentColor = customization.color || '#333333';
            
            // Get default icon if no custom one set
            if (!currentIcon) {
                if (lastFolderName.toLowerCase().includes('gman')) currentIcon = '👤';
                else if (lastFolderName.toLowerCase().includes('alyx')) currentIcon = '👩';
                else if (lastFolderName.toLowerCase().includes('russell')) currentIcon = '👨‍🔬';
                else if (lastFolderName.toLowerCase().includes('eli')) currentIcon = '👨‍🦳';
                else if (lastFolderName.toLowerCase().includes('vortigaunt')) currentIcon = '👽';
                else if (lastFolderName.toLowerCase().includes('combine')) currentIcon = '🤖';
                else if (lastFolderName.toLowerCase().includes('jeff')) currentIcon = '🧟';
                else if (lastFolderName.toLowerCase().includes('zombie')) currentIcon = '🧟‍♂️';
                else currentIcon = '📁';
            }
            
            // Create popup
            const overlay = document.createElement('div');
            overlay.className = 'customize-popup-overlay';
            overlay.onclick = () => closeFolderCustomization();
            
            const popup = document.createElement('div');
            popup.className = 'folder-customize-popup';
            popup.innerHTML = `
                <h4>⚙️ Ordner anpassen: ${lastFolderName}</h4>
                
                <div class="customize-field">
                    <label>Icon (Emoji):</label>
                    <input type="text" id="customIcon" value="${currentIcon}" maxlength="2" onInput="updateCustomizationPreview()">
                    <span class="icon-preview" id="iconPreview">${currentIcon}</span>
                </div>
                
                <div class="customize-field">
                    <label>Hintergrundfarbe:</label>
                    <input type="color" id="customColor" value="${currentColor}" onInput="updateCustomizationPreview()">
                    <span class="color-preview" id="colorPreview" style="background: ${currentColor};"></span>
                </div>
                
                <div class="customize-field">
                    <label>Voreinstellungen:</label>
                    <select id="presetSelect" onchange="applyPreset('${folderName}')">
                        <option value="">-- Voreinstellung wählen --</option>
                        <option value="gman">G-Man (👤, #4a148c)</option>
                        <option value="alyx">Alyx (👩, #1a237e)</option>
                        <option value="russell">Russell (👨‍🔬, #00695c)</option>
                        <option value="eli">Eli (👨‍🦳, #e65100)</option>
                        <option value="vortigaunt">Vortigaunt (👽, #263238)</option>
                        <option value="combine">Combine (🤖, #b71c1c)</option>
                        <option value="jeff">Jeff (🧟, #2e7d32)</option>
                        <option value="zombie">Zombie (🧟‍♂️, #424242)</option>
                        <option value="folder">Standard (📁, #333333)</option>
                    </select>
                </div>
                
                <div class="customize-buttons">
                    <button class="btn btn-secondary" onclick="resetFolderCustomization('${folderName}')">Zurücksetzen</button>
                    <button class="btn btn-secondary" onclick="closeFolderCustomization()">Abbrechen</button>
                    <button class="btn btn-success" onclick="saveFolderCustomization('${folderName}')">Speichern</button>
                </div>
            `;
            
            popup.onclick = (e) => e.stopPropagation();
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
        }

        function updateCustomizationPreview() {
            const iconInput = document.getElementById('customIcon');
            const colorInput = document.getElementById('customColor');
            const iconPreview = document.getElementById('iconPreview');
            const colorPreview = document.getElementById('colorPreview');
            
            if (iconInput && iconPreview) {
                iconPreview.textContent = iconInput.value || '📁';
            }
            
            if (colorInput && colorPreview) {
                colorPreview.style.background = colorInput.value;
            }
        }

        function applyPreset(folderName) {
            const presetSelect = document.getElementById('presetSelect');
            const iconInput = document.getElementById('customIcon');
            const colorInput = document.getElementById('customColor');
            
            const presets = {
                'gman': { icon: '👤', color: '#4a148c' },
                'alyx': { icon: '👩', color: '#1a237e' },
                'russell': { icon: '👨‍🔬', color: '#00695c' },
                'eli': { icon: '👨‍🦳', color: '#e65100' },
                'vortigaunt': { icon: '👽', color: '#263238' },
                'combine': { icon: '🤖', color: '#b71c1c' },
                'jeff': { icon: '🧟', color: '#2e7d32' },
                'zombie': { icon: '🧟‍♂️', color: '#424242' },
                'folder': { icon: '📁', color: '#333333' }
            };
            
            const preset = presets[presetSelect.value];
            if (preset) {
                iconInput.value = preset.icon;
                colorInput.value = preset.color;
                updateCustomizationPreview();
            }
        }

        function saveFolderCustomization(folderName) {
            const iconInput = document.getElementById('customIcon');
            const colorInput = document.getElementById('customColor');
            
            folderCustomizations[folderName] = {
                icon: iconInput.value || '📁',
                color: colorInput.value || '#333333'
            };
            
            saveFolderCustomizations();
            closeFolderCustomization();
            
            // Refresh the folder view
            if (document.getElementById('folderGrid').style.display !== 'none') {
                showFolderGrid();
            } else {
                showFolderFiles(folderName);
            }
            
            // Refresh main table to show updated badges
            renderFileTable();
            
            updateStatus('Ordner-Anpassung gespeichert');
        }

        function resetFolderCustomization(folderName) {
            if (confirm('Möchten Sie die Anpassungen für diesen Ordner wirklich zurücksetzen?')) {
                delete folderCustomizations[folderName];
                saveFolderCustomizations();
                closeFolderCustomization();
                
                // Refresh the folder view
                if (document.getElementById('folderGrid').style.display !== 'none') {
                    showFolderGrid();
                } else {
                    showFolderFiles(folderName);
                }
                
                // Refresh main table to show updated badges
                renderFileTable();
                
                updateStatus('Ordner-Anpassung zurückgesetzt');
            }
        }

        function closeFolderCustomization() {
            const overlay = document.querySelector('.customize-popup-overlay');
            const popup = document.querySelector('.folder-customize-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        // Import/Export functions
        function showImportDialog() {
            document.getElementById('importDialog').style.display = 'flex';
            document.getElementById('columnSelection').style.display = 'none';
            document.getElementById('analyzeDataBtn').style.display = 'block';
            document.getElementById('startImportBtn').style.display = 'none';
            document.getElementById('importData').value = '';
        }

        function closeImportDialog() {
            document.getElementById('importDialog').style.display = 'none';
            document.getElementById('importData').value = '';
            document.getElementById('columnSelection').style.display = 'none';
            document.getElementById('analyzeDataBtn').style.display = 'block';
            document.getElementById('startImportBtn').style.display = 'none';
        }

        let parsedImportData = null;
        let detectedColumns = null;

        function analyzeImportData() {
            const data = document.getElementById('importData').value.trim();
            if (!data) {
                alert('Bitte fügen Sie erst Daten ein!');
                return;
            }
            
            try {
                // Parse the data
                if (data.includes('{|') && data.includes('|-') && data.includes('|')) {
                    // Wiki table format
                    parsedImportData = parseWikiTable(data);
                } else {
                    // Try pipe format
                    parsedImportData = parsePipeFormat(data);
                }
                
                if (!parsedImportData || parsedImportData.length === 0) {
                    alert('Keine gültigen Daten gefunden!\n\nUnterstützte Formate:\n• Wiki-Tabelle\n• Pipe-Format (Datei|Text|Text)');
                    return;
                }
                
                // Detect columns
                detectedColumns = detectColumns(parsedImportData);
                
                if (detectedColumns.filenameColumn === -1) {
                    alert('Keine Dateinamen-Spalte gefunden!\n\nDateinamen sollten erkennbar sein als:\n• Code-Tags: <code>dateiname</code>\n• Dateinamen mit Zahlen: 02_01103\n• Dateinamen mit Erweiterung: datei.mp3');
                    return;
                }
                
                // Show column selection UI
                setupColumnSelection();
                
            } catch (error) {
                console.error('Import analysis error:', error);
                alert('Fehler beim Analysieren der Daten: ' + error.message);
            }
        }

        function parseWikiTable(data) {
            const rows = [];
            
            // Split by row separators
            const lines = data.split('\n');
            let currentRow = [];
            let inTableRow = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Skip table start/end and headers
                if (line.startsWith('{|') || line.startsWith('|}') || line.startsWith('!')) {
                    continue;
                }
                
                // Row separator
                if (line === '|-') {
                    if (currentRow.length > 0) {
                        rows.push([...currentRow]);
                        currentRow = [];
                    }
                    inTableRow = true;
                    continue;
                }
                
                // Cell content
                if (line.startsWith('|') && inTableRow) {
                    let cellContent = line.substring(1).trim();
                    
                    // Remove HTML comments
                    cellContent = cellContent.replace(/<!--.*?-->/g, '').trim();
                    
                    // Clean up code tags
                    cellContent = cellContent.replace(/<\/?code>/g, '');
                    
                    // Skip empty cells
                    if (cellContent && cellContent !== '|') {
                        currentRow.push(cellContent);
                    }
                }
            }
            
            // Add last row if exists
            if (currentRow.length > 0) {
                rows.push(currentRow);
            }
            
            // Filter out rows with less than 2 columns
            return rows.filter(row => row.length >= 2);
        }

        function parsePipeFormat(data) {
            const lines = data.split('\n');
            const rows = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && trimmed.includes('|')) {
                    const parts = trimmed.split('|').map(p => p.trim()).filter(p => p.length > 0);
                    if (parts.length >= 2) {
                        rows.push(parts);
                    }
                }
            }
            
            return rows;
        }

        function detectColumns(rows) {
            const columnCount = Math.max(...rows.map(row => row.length));
            
            // Intelligent filename detection with database comparison
            let bestFilenameColumn = -1;
            let bestScore = -1;
            
            for (let col = 0; col < columnCount; col++) {
                let score = 0;
                let sampleCount = 0;
                
                for (const row of rows.slice(0, Math.min(10, rows.length))) {
                    if (row[col]) {
                        const cell = row[col].trim();
                        sampleCount++;
                        
                        // Pattern-based scoring
                        if (/^\d+[_\d]*$/.test(cell)) { // Numbers with underscores (02_01103)
                            score += 5;
                        } else if (/^[a-zA-Z0-9_\-]+\.(mp3|wav|ogg)$/i.test(cell)) { // Audio files
                            score += 8;
                        } else if (/^[a-zA-Z0-9_\-]{3,15}$/.test(cell)) { // Short alphanumeric codes
                            score += 2;
                        } else if (cell.length > 50) { // Long text unlikely to be filename
                            score -= 3;
                        } else if (/[.!?,:;]/.test(cell)) { // Punctuation suggests text content
                            score -= 2;
                        }
                        
                        // Database-based scoring - check if similar files exist
                        const cleanCell = cell.replace(/\.(mp3|wav|ogg)$/i, '');
                        for (const dbFilename of Object.keys(filePathDatabase)) {
                            const dbClean = dbFilename.replace(/\.(mp3|wav|ogg)$/i, '');
                            if (dbClean.includes(cleanCell) || cleanCell.includes(dbClean)) {
                                score += 10; // Strong database match
                                break;
                            }
                        }
                        
                        // Check for exact database matches
                        if (filePathDatabase[cell] || 
                            filePathDatabase[cell + '.mp3'] || 
                            filePathDatabase[cell + '.wav']) {
                            score += 15; // Perfect database match
                        }
                    }
                }
                
                // Normalize score by sample count
                const normalizedScore = sampleCount > 0 ? score / sampleCount : -999;
                
                if (normalizedScore > bestScore) {
                    bestScore = normalizedScore;
                    bestFilenameColumn = col;
                }
            }
            
            return {
                suggestedFilenameColumn: bestFilenameColumn,
                columnCount: columnCount,
                confidence: bestScore
            };
        }

        function setupColumnSelection() {
            const columnSelection = document.getElementById('columnSelection');
            const filenameSelect = document.getElementById('filenameColumn');
            const englishSelect = document.getElementById('englishColumn');
            const germanSelect = document.getElementById('germanColumn');
            
            // Clear previous options
            filenameSelect.innerHTML = '<option value="">-- Bitte auswählen --</option>';
            englishSelect.innerHTML = '<option value="">-- Bitte auswählen --</option>';
            germanSelect.innerHTML = '<option value="">-- Keine / Nicht vorhanden --</option>';
            
            // Get column headers/samples for preview
            const sampleRow = parsedImportData[0] || [];
            const columnCount = detectedColumns.columnCount;
            const suggestedFilename = detectedColumns.suggestedFilenameColumn;
            
            // Add options for each column to all selects
            for (let i = 0; i < columnCount; i++) {
                const sample = sampleRow[i] || '';
                const preview = sample.length > 30 ? sample.substring(0, 30) + '...' : sample;
                
                // Check if this looks like filename content for better labeling
                const isLikelyFilename = (suggestedFilename === i);
                const confidence = isLikelyFilename ? detectColumnConfidence(i) : '';
                
                const optionText = `Spalte ${i + 1}: ${preview}${confidence}`;
                
                // Add to all dropdowns
                filenameSelect.appendChild(new Option(optionText, i));
                englishSelect.appendChild(new Option(optionText, i));
                germanSelect.appendChild(new Option(optionText, i));
            }
            
            // Set intelligent suggestions
            if (suggestedFilename >= 0) {
                filenameSelect.value = suggestedFilename;
                
                // Auto-suggest English column (first non-filename column)
                const otherColumns = Array.from({length: columnCount}, (_, i) => i).filter(i => i !== suggestedFilename);
                if (otherColumns.length > 0) {
                    englishSelect.value = otherColumns[0];
                }
                
                // If there's a third column, suggest it for German
                if (otherColumns.length > 1) {
                    germanSelect.value = otherColumns[1];
                }
            } else if (columnCount === 2) {
                // If no clear detection but only 2 columns, suggest both
                filenameSelect.value = 0;
                englishSelect.value = 1;
            }
            
            // Generate preview table
            generatePreviewTable();
            
            // Show column selection
            columnSelection.style.display = 'block';
            document.getElementById('analyzeDataBtn').style.display = 'none';
            document.getElementById('startImportBtn').style.display = 'block';
            
            const confidenceMsg = detectedColumns.confidence > 5 ? 
                'Hohe Konfidenz bei Dateinamen-Erkennung' : 
                'Niedrige Konfidenz - bitte Auswahl prüfen';
            updateStatus(`Daten analysiert - ${confidenceMsg}`);
        }

        function detectColumnConfidence(columnIndex) {
            if (columnIndex !== detectedColumns.suggestedFilenameColumn) return '';
            
            if (detectedColumns.confidence > 10) return ' ✅ (sehr sicher)';
            else if (detectedColumns.confidence > 5) return ' ✅ (sicher)';
            else if (detectedColumns.confidence > 0) return ' ⚠️ (unsicher)';
            else return ' ❓ (geraten)';
        }

        function updatePreviewHighlighting() {
            generatePreviewTable();
        }

        function generatePreviewTable() {
            const previewTable = document.getElementById('previewTableContent');
            const previewRows = parsedImportData.slice(0, 3);
            const columnCount = detectedColumns.columnCount;
            
            // Get current selections
            const selectedFilename = parseInt(document.getElementById('filenameColumn').value);
            const selectedEnglish = parseInt(document.getElementById('englishColumn').value);
            const selectedGerman = parseInt(document.getElementById('germanColumn').value);
            
            let html = '<thead><tr>';
            for (let i = 0; i < columnCount; i++) {
                let bgColor = '#2a2a2a';
                let label = `Spalte ${i + 1}`;
                
                if (i === selectedFilename) {
                    bgColor = '#4caf50';
                    label += ' (Dateinamen)';
                } else if (i === selectedEnglish) {
                    bgColor = '#2196f3';
                    label += ' (EN Text)';
                } else if (i === selectedGerman) {
                    bgColor = '#ff9800';
                    label += ' (DE Text)';
                }
                
                html += `<th style="padding: 8px; background: ${bgColor}; color: white; font-size: 11px;">
                    ${label}
                </th>`;
            }
            html += '</tr></thead><tbody>';
            
            previewRows.forEach((row, rowIndex) => {
                html += '<tr>';
                for (let i = 0; i < columnCount; i++) {
                    const cellContent = row[i] || '';
                    const displayContent = cellContent.length > 50 ? cellContent.substring(0, 50) + '...' : cellContent;
                    
                    let bgColor = 'transparent';
                    if (i === selectedFilename) {
                        bgColor = 'rgba(76, 175, 80, 0.1)';
                    } else if (i === selectedEnglish) {
                        bgColor = 'rgba(33, 150, 243, 0.1)';
                    } else if (i === selectedGerman) {
                        bgColor = 'rgba(255, 152, 0, 0.1)';
                    }
                    
                    html += `<td style="padding: 8px; border-bottom: 1px solid #444; background: ${bgColor}; font-size: 11px; max-width: 200px; overflow: hidden;">
                        ${escapeHtml(displayContent)}
                    </td>`;
                }
                html += '</tr>';
            });
            
            html += '</tbody>';
            previewTable.innerHTML = html;
        }

        function startImportProcess() {
            const filenameColumn = parseInt(document.getElementById('filenameColumn').value);
            const englishColumn = parseInt(document.getElementById('englishColumn').value);
            const germanColumn = document.getElementById('germanColumn').value ? parseInt(document.getElementById('germanColumn').value) : -1;
            
            if (isNaN(filenameColumn)) {
                alert('Bitte wählen Sie die Spalte für die Dateinamen aus!');
                return;
            }
            
            if (isNaN(englishColumn)) {
                alert('Bitte wählen Sie die Spalte für den englischen Text aus!');
                return;
            }
            
            if (filenameColumn === englishColumn) {
                alert('Dateinamen und englischer Text können nicht in derselben Spalte sein!');
                return;
            }
            
            if (germanColumn >= 0 && (germanColumn === filenameColumn || germanColumn === englishColumn)) {
                alert('Deutsche Text-Spalte muss unterschiedlich zu den anderen Spalten sein!');
                return;
            }
            
            let imported = 0;
            let updated = 0;
            let notFound = [];
            let databaseMatches = 0;
            
            // Process each row
            parsedImportData.forEach((row, index) => {
                const filename = row[filenameColumn];
                const englishText = row[englishColumn] || '';
                const germanText = germanColumn >= 0 ? (row[germanColumn] || '') : '';
                
                if (!filename || !englishText) {
                    console.log(`Skipping row ${index + 1}: missing filename or English text`);
                    return;
                }
                
                // Clean filename
                let cleanFilename = filename.replace(/\.(mp3|wav|ogg)$/i, '');
                
                // Try to find file in database
                let found = false;
                
                // Try exact match first
                const extensions = ['.mp3', '.wav', '.ogg'];
                for (const ext of extensions) {
                    const fullFilename = cleanFilename + ext;
                    if (filePathDatabase[fullFilename]) {
                        const pathInfo = filePathDatabase[fullFilename][0];
                        updateTextDatabase(fullFilename, pathInfo, englishText, germanText);
                        imported++;
                        databaseMatches++;
                        found = true;
                        break;
                    }
                }
                
                // Try fuzzy search if not found
                if (!found) {
                    for (const [dbFilename, paths] of Object.entries(filePathDatabase)) {
                        const dbCleanName = dbFilename.replace(/\.(mp3|wav|ogg)$/i, '');
                        if (dbCleanName.includes(cleanFilename) || cleanFilename.includes(dbCleanName)) {
                            const pathInfo = paths[0];
                            updateTextDatabase(dbFilename, pathInfo, englishText, germanText);
                            imported++;
                            found = true;
                            break;
                        }
                    }
                }
                
                if (!found) {
                    notFound.push(filename);
                }
            });
            
            // Update texts for files already in the current project
            files.forEach(file => {
                const fileKey = `${file.folder}/${file.filename}`;
                if (textDatabase[fileKey]) {
                    let wasUpdated = false;
                    if (textDatabase[fileKey].en && textDatabase[fileKey].en !== file.enText) {
                        file.enText = textDatabase[fileKey].en;
                        wasUpdated = true;
                    }
                    if (textDatabase[fileKey].de && textDatabase[fileKey].de !== file.deText) {
                        file.deText = textDatabase[fileKey].de;
                        wasUpdated = true;
                    }
                    if (wasUpdated) {
                        updated++;
                    }
                }
            });
            
            if (imported > 0 || updated > 0) {
                isDirty = true;
                saveTextDatabase();
                if (updated > 0) {
                    renderFileTable();
                    updateProgressStats();
                }
                
                let message = `${imported} Texte in die Datenbank importiert`;
                if (updated > 0) {
                    message += `\n${updated} Dateien im aktuellen Projekt aktualisiert`;
                }
                
                updateStatus(message);
                closeImportDialog();
                
                const summaryMessage = `✅ Import erfolgreich abgeschlossen!\n\n` +
                    `📊 Statistik:\n` +
                    `• ${imported} Texte importiert (${databaseMatches} exakte DB-Matches)\n` +
                    `• ${updated} Projekt-Dateien aktualisiert\n` +
                    `• ${parsedImportData.length} Zeilen verarbeitet\n` +
                    `• ${notFound.length} nicht gefunden\n\n` +
                    `🎯 Spalten-Zuordnung:\n` +
                    `• Dateinamen: Spalte ${filenameColumn + 1}\n` +
                    `• Englisch: Spalte ${englishColumn + 1}\n` +
                    `• Deutsch: ${germanColumn >= 0 ? `Spalte ${germanColumn + 1}` : 'Nicht verwendet'}`;
                
                setTimeout(() => {
                    alert(summaryMessage + (notFound.length > 0 && notFound.length <= 10 ? `\n\n❌ Nicht gefunden:\n${notFound.join('\n')}` : 
                          notFound.length > 10 ? `\n\n❌ ${notFound.length} Dateien nicht gefunden (erste 5):\n${notFound.slice(0, 5).join('\n')}\n...` : ''));
                }, 100);
            } else {
                alert('❌ Keine Dateien konnten importiert werden!\n\n' +
                      'Mögliche Gründe:\n' +
                      '1. Dateien wurden nicht in der Datenbank gefunden\n' +
                      '2. Falsche Spalten-Zuordnung\n' +
                      '3. Leere oder ungültige Daten\n\n' +
                      `📊 Versucht: ${parsedImportData.length} Zeilen\n` +
                      `❌ Nicht gefunden: ${notFound.length}\n\n` +
                      'Tipp: Scannen Sie zuerst den Ordner mit den Audio-Dateien.');
            }
        }
        
        function updateTextDatabase(filename, pathInfo, englishText, germanText) {
            const fileKey = `${pathInfo.folder}/${filename}`;
            if (!textDatabase[fileKey]) {
                textDatabase[fileKey] = {};
            }
            
            if (englishText) {
                textDatabase[fileKey].en = englishText;
            }
            if (germanText) {
                textDatabase[fileKey].de = germanText;
            }
        }

        // Export functions
        function showExportDialog() {
            // Auto-check and scan if needed
            if (!checkFileAccessWithAutoScan('ZIP-Export')) {
                return; // Cancelled or no files selected
            }
            
            document.getElementById('exportDialog').style.display = 'flex';
            document.getElementById('exportProgress').style.display = 'none';
            document.getElementById('downloadSection').style.display = 'none';
            document.getElementById('startExportBtn').style.display = 'block';
            document.getElementById('startExportBtn').disabled = false;
        }

// =========================== CLOSEEXPORTDIALOG START ===========================
function closeExportDialog() {
    document.getElementById('exportDialog').style.display = 'none';
    if (typeof exportZip !== 'undefined' && exportZip !== null) {
        exportZip = null;
    }
}
// =========================== CLOSEEXPORTDIALOG END ===========================



// =========================== STARTEXPORT START ===========================
async function startExport() {
    const selectedFiles = files.filter(f => f.selected);
    if (selectedFiles.length === 0) {
        alert('Keine Dateien ausgewählt!');
        return;
    }

    // Final check before export - auto-scan if needed
    const scanResult = checkAndAutoScan(selectedFiles, 'ZIP-Export Start');
    if (scanResult === true) {
        // Scan started, close dialog and wait
        updateStatus('ZIP-Export: Warte auf Ordner-Scan...');
        closeExportDialog();
        return;
    } else if (scanResult === false) {
        // User cancelled
        return;
    }
    // scanResult === null means all files are accessible, continue

    const prefix = document.getElementById('exportPrefix').value || 'HLA_';
    const format = document.getElementById('exportFormat').value;
    const createCSV = document.getElementById('exportCSV').checked;

    document.getElementById('startExportBtn').style.display = 'none';
    document.getElementById('exportProgress').style.display = 'block';
    
    const exportStatus = document.getElementById('exportStatus');
    const exportProgressFill = document.getElementById('exportProgressFill');
    const exportFileList = document.getElementById('exportFileList');

    exportStatus.textContent = 'Erstelle ZIP-Archiv...';
    exportProgressFill.style.width = '0%';
    exportFileList.innerHTML = '';

    try {
        exportZip = new JSZip();
        let processedFiles = 0;
        let successCount = 0;
        let errorCount = 0;

        const exportData = [];
        
        for (let i = 0; i < selectedFiles.length; i++) {
            const file = selectedFiles[i];
            const num = String(i + 1).padStart(3, '0');
            let newName;
            
            switch(format) {
                case 'number_folder':
                    newName = `${num}_${file.folder.replace(/\//g, '_')}_${file.filename}`;
                    break;
                case 'folder_number':
                    newName = `${file.folder.replace(/\//g, '_')}_${num}_${file.filename}`;
                    break;
                case 'prefix_only':
                    newName = `${prefix}${file.filename}`;
                    break;
            }
            
            exportData.push({
                originalPath: file.fullPath,
                newName: newName,
                file: file,
                index: i
            });
        }

        for (const data of exportData) {
            const file = data.file;
            const progress = Math.round((processedFiles / selectedFiles.length) * 100);
            
            exportStatus.textContent = `Verarbeite ${file.filename}... (${processedFiles + 1}/${selectedFiles.length})`;
            exportProgressFill.style.width = progress + '%';
            
            const listItem = document.createElement('div');
            listItem.className = 'file-list-item';
            listItem.textContent = `${data.newName} ← ${file.filename}`;
            exportFileList.appendChild(listItem);
            
            try {
                // Nutze die dynamische Audio-Suche
                const audioResult = findAudioInFilePathCache(file.filename, file.folder);
                
                if (audioResult && audioResult.audioFile) {
                    exportZip.file(data.newName, audioResult.audioFile);
                    listItem.classList.add('success');
                    listItem.textContent += ' ✓';
                    successCount++;
                    console.log(`[EXPORT] Success: ${file.filename} -> ${data.newName}`);
                } else {
                    listItem.classList.add('error');
                    listItem.textContent += ' ✗ (Audio nicht gefunden)';
                    errorCount++;
                    console.log(`[EXPORT] Error: ${file.filename} - Audio nicht gefunden`);
                }
            } catch (error) {
                listItem.classList.add('error');
                listItem.textContent += ' ✗ (Fehler)';
                errorCount++;
                console.error(`[EXPORT] Error processing file: ${file.filename}`, error);
            }
            
            processedFiles++;
            
            if (processedFiles % 10 === 0) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }

        if (createCSV && successCount > 0) {
            exportStatus.textContent = 'Erstelle CSV-Datei...';
            
            const csvContent = 'Original Dateiname;Ordner;Export Name;EN Text;DE Text;Fertig\n' +
                exportData.map(d => 
                    `${d.file.filename};${d.file.folder};${d.newName};"${d.file.enText.replace(/"/g, '""')}";"${d.file.deText.replace(/"/g, '""')}";${d.file.completed ? 'Ja' : 'Nein'}`
                ).join('\n');
            
            exportZip.file(`translations_${currentProject.name}_${new Date().toISOString().split('T')[0]}.csv`, csvContent);
        }

        const manifest = {
            project: currentProject.name,
            exportDate: new Date().toISOString(),
            prefix: prefix,
            format: format,
            totalFiles: selectedFiles.length,
            successfulFiles: successCount,
            failedFiles: errorCount,
            files: exportData.map(d => ({
                original: d.file.filename,
                exported: d.newName,
                folder: d.file.folder,
                enText: d.file.enText,
                deText: d.file.deText,
                completed: d.file.completed
            }))
        };
        
        exportZip.file('export_manifest.json', JSON.stringify(manifest, null, 2));

        exportStatus.textContent = 'Finalisiere ZIP-Archiv...';
        exportProgressFill.style.width = '100%';
        
        document.getElementById('downloadSection').style.display = 'block';
        document.getElementById('downloadBtn').disabled = false;
        
        if (errorCount > 0) {
            exportStatus.textContent = `Export abgeschlossen mit Fehlern. ${successCount} Dateien erfolgreich, ${errorCount} Fehler.`;
        } else {
            exportStatus.textContent = `Export erfolgreich abgeschlossen! ${successCount} Dateien hinzugefügt.`;
        }
        
        updateStatus(`ZIP-Export vorbereitet: ${successCount}/${selectedFiles.length} Dateien`);

    } catch (error) {
        console.error('Export error:', error);
        exportStatus.textContent = 'Fehler beim Export: ' + error.message;
        document.getElementById('startExportBtn').style.display = 'block';
        document.getElementById('startExportBtn').disabled = false;
    }
}
// =========================== STARTEXPORT END ===========================

        async function downloadZip() {
            if (!exportZip) {
                alert('Kein Export verfügbar!');
                return;
            }

            try {
                document.getElementById('downloadBtn').disabled = true;
                document.getElementById('downloadBtn').textContent = 'Erstelle Download...';
                
                const content = await exportZip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: {
                        level: 6
                    }
                });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `${currentProject.name}_export_${new Date().toISOString().split('T')[0]}.zip`;
                link.click();
                
                setTimeout(() => {
                    URL.revokeObjectURL(link.href);
                }, 1000);
                
                updateStatus('ZIP-Download gestartet');
                
            } catch (error) {
                console.error('Download error:', error);
                alert('Fehler beim Download: ' + error.message);
            } finally {
                document.getElementById('downloadBtn').disabled = false;
                document.getElementById('downloadBtn').textContent = '📦 ZIP-Datei herunterladen';
            }
        }

function checkFileAccess() {
    const totalFiles = files.length;
    const selectedFiles = files.filter(f => f.selected);
    let accessibleFiles = 0;
    let inaccessibleFiles = 0;
    
    selectedFiles.forEach(file => {
        // Dynamisch prüfen ob Datei verfügbar ist
        let isAccessible = false;
        
        if (filePathDatabase[file.filename]) {
            const matchingPaths = filePathDatabase[file.filename].filter(pathInfo => {
                // Exakte Ordner-Übereinstimmung
                if (pathInfo.folder === file.folder) {
                    return true;
                }
                
                // Normalisierte Ordner-Übereinstimmung
                const normalizedFileFolder = normalizeFolderPath(file.folder);
                const normalizedDbFolder = normalizeFolderPath(pathInfo.folder);
                return normalizedFileFolder === normalizedDbFolder;
            });
            
            if (matchingPaths.length > 0) {
                const bestPath = matchingPaths[0];
                if (audioFileCache[bestPath.fullPath]) {
                    isAccessible = true;
                }
            }
        }
        
        if (isAccessible) {
            accessibleFiles++;
        } else {
            inaccessibleFiles++;
        }
    });
    
    const stats = {
        totalFiles: totalFiles,
        selectedFiles: selectedFiles.length,
        accessibleFiles: accessibleFiles,
        inaccessibleFiles: inaccessibleFiles
    };
    
    console.log('File Access Stats:', stats);
    return stats;
}

        function updateFileAccessStatus() {
            const accessStatus = document.getElementById('accessStatus');
            const stats = checkFileAccess();
            
            if (stats.selectedFiles === 0) {
                accessStatus.textContent = '📂 Keine Auswahl';
                accessStatus.className = 'access-status none';
                accessStatus.title = 'Keine Dateien ausgewählt - Klicken für Info';
            } else if (stats.inaccessibleFiles === 0) {
                accessStatus.textContent = `✅ ${stats.selectedFiles} verfügbar`;
                accessStatus.className = 'access-status good';
                accessStatus.title = 'Alle Dateien verfügbar - Export möglich';
            } else if (stats.accessibleFiles === 0) {
                accessStatus.textContent = `❌ ${stats.selectedFiles} blockiert`;
                accessStatus.className = 'access-status error';
                accessStatus.title = 'Keine Dateien verfügbar - Klicken zum Scannen';
            } else {
                accessStatus.textContent = `⚠️ ${stats.accessibleFiles}/${stats.selectedFiles} verfügbar`;
                accessStatus.className = 'access-status warning';
                accessStatus.title = `${stats.inaccessibleFiles} Dateien nicht verfügbar - Klicken zum Scannen`;
            }
        }

        // Backup and Restore functionality
        function backupData() {
            const backup = {
                version: '3.6.0',
                date: new Date().toISOString(),
                projects: projects,
                textDatabase: textDatabase,
                filePathDatabase: filePathDatabase,
                folderCustomizations: folderCustomizations,
                currentProjectId: currentProject?.id
            };
            
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `hla_translation_backup_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            updateStatus('Backup erstellt');
        }

        function restoreData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const backup = JSON.parse(event.target.result);
                        
                        if (!backup.version || !backup.projects) {
                            throw new Error('Ungültiges Backup-Format');
                        }
                        
                        if (!confirm('Dies wird alle aktuellen Daten überschreiben. Fortfahren?')) {
                            return;
                        }
                        
                        projects = backup.projects;
                        textDatabase = backup.textDatabase || {};
                        filePathDatabase = backup.filePathDatabase || {};
                        folderCustomizations = backup.folderCustomizations || {};
                        
                        // Migrate restored projects if they don't have icon/color
                        let migrationNeeded = false;
                        projects.forEach(project => {
                            if (!project.hasOwnProperty('icon')) {
                                project.icon = '🗂️';
                                migrationNeeded = true;
                            }
                            if (!project.hasOwnProperty('color')) {
                                project.color = '#333333';
                                migrationNeeded = true;
                            }
                        });
                        
                        if (migrationNeeded) {
                            console.log('Wiederhergestellte Projekte migriert: Icons und Farben hinzugefügt');
                        }
                        
                        saveProjects();
                        saveTextDatabase();
                        saveFilePathDatabase();
                        saveFolderCustomizations();
                        
                        renderProjects();
                        
                        if (backup.currentProjectId) {
                            selectProject(backup.currentProjectId);
                        } else if (projects.length > 0) {
                            selectProject(projects[0].id);
                        }
                        
                        updateStatus('Backup wiederhergestellt');
                    } catch (err) {
                        alert('Fehler beim Wiederherstellen: ' + err.message);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

// =========================== FINDDUPLICATES START ===========================
function findDuplicates() {
    const allDuplicates = new Map();
    
    // Finde Dateien mit mehreren Pfaden in der gleichen Datei-Gruppe
    Object.entries(filePathDatabase).forEach(([filename, paths]) => {
        if (paths.length > 1) {
            // Prüfe ob es echte Duplikate sind (gleicher Ordner) oder nur gleiche Dateinamen in verschiedenen Ordnern
            const folderGroups = new Map();
            
            paths.forEach((pathInfo, index) => {
                const folder = pathInfo.folder;
                if (!folderGroups.has(folder)) {
                    folderGroups.set(folder, []);
                }
                folderGroups.get(folder).push({
                    filename: filename,
                    pathInfo: pathInfo,
                    pathIndex: index,
                    key: `${pathInfo.folder}/${filename}`,
                    originalFolder: pathInfo.folder
                });
            });
            
            // Nur wenn der GLEICHE Ordner mehrere Einträge hat, ist es ein Duplikat
            folderGroups.forEach((group, folderName) => {
                if (group.length > 1) {
                    const duplicateKey = `duplicate_${folderName}/${filename}`;
                    allDuplicates.set(duplicateKey, group);
                    console.log(`Duplikat gefunden: ${filename} in ${folderName} (${group.length} Einträge)`);
                }
            });
        }
    });
    
    console.log(`Gefunden: ${allDuplicates.size} echte Duplikate`);
    return allDuplicates;
}
// =========================== FINDDUPLICATES END ===========================

        function scoreDuplicateItem(item) {
            let score = 0;
            const fileKey = item.key;
            
            // Check if has EN text in textDatabase
            if (textDatabase[fileKey] && textDatabase[fileKey].en) {
                score += 10;
            }
            
            // Check if is in any project
            const isInProject = projects.some(project => 
                project.files && project.files.some(file => 
                    file.filename === item.filename && file.folder === item.pathInfo.folder
                )
            );
            if (isInProject) {
                score += 20;
            }
            
            // Check if has audio file cached
            if (audioFileCache[item.pathInfo.fullPath]) {
                score += 5;
            }
            
            // Check if has German text
            if (textDatabase[fileKey] && textDatabase[fileKey].de) {
                score += 8;
            }
            
            // Tiebreaker: prefer first occurrence (lower pathIndex)
            score += 1 - (item.pathIndex * 0.1);
            
            return score;
        }

        function cleanupDuplicates() {
            const duplicates = findDuplicates();
            
            if (duplicates.size === 0) {
                alert('✅ Keine Duplikate gefunden!\n\nDie Datenbank ist bereits sauber.');
                return;
            }
            
            // Calculate scores and determine what to keep/delete
            const cleanupPlan = [];
            let totalToDelete = 0;
            
            duplicates.forEach((group, key) => {
                const scoredItems = group.map(item => ({
                    ...item,
                    score: scoreDuplicateItem(item)
                }));
                
                // Sort by score (highest first)
                scoredItems.sort((a, b) => b.score - a.score);
                
                // Keep the highest scored item, mark others for deletion
                const toKeep = scoredItems[0];
                const toDelete = scoredItems.slice(1);
                
                cleanupPlan.push({
                    key: key,
                    keep: toKeep,
                    delete: toDelete
                });
                
                totalToDelete += toDelete.length;
            });
            
            // Show confirmation dialog
            showCleanupConfirmation(cleanupPlan, totalToDelete);
        }

        function showCleanupConfirmation(cleanupPlan, totalToDelete) {
            const duplicateGroups = cleanupPlan.length;
            
            const confirmMessage = `🧹 Duplikate-Bereinigung\n\n` +
                `Gefunden: ${duplicateGroups} Duplikate-Gruppen\n` +
                `Zu löschen: ${totalToDelete} Einträge\n` +
                `Zu behalten: ${duplicateGroups} Einträge\n\n` +
                `Kriterien für das Behalten:\n` +
                `• In Projekt vorhanden: +20 Punkte\n` +
                `• Hat EN Text: +10 Punkte\n` +
                `• Hat DE Text: +8 Punkte\n` +
                `• Audio verfügbar: +5 Punkte\n\n` +
                `Möchten Sie fortfahren?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Execute cleanup
            executeCleanup(cleanupPlan, totalToDelete);
        }

function executeCleanup(cleanupPlan, totalToDelete) {
    let deletedCount = 0;
    let mergedCount = 0;
    const deletedItems = [];
    
    updateStatus('Bereinige Duplikate intelligent...');
    
    // Execute cleanup plan with intelligent merging
    cleanupPlan.forEach(plan => {
        const filename = plan.keep.filename;
        
        if (!filePathDatabase[filename]) {
            console.log(`Warning: ${filename} not found in database during cleanup`);
            return;
        }
        
        // Collect all items to delete and the item to keep
        const toDelete = plan.delete;
        const toKeep = plan.keep;
        
        // Find the best item to keep (highest score)
        let bestItem = toKeep;
        let bestScore = toKeep.score;
        
        // Check all items including those marked for deletion to find the absolute best
        [...plan.delete, plan.keep].forEach(item => {
            const score = scoreDuplicateItem(item);
            if (score > bestScore) {
                bestScore = score;
                bestItem = item;
            }
        });
        
        console.log(`Cleaning up ${filename}: keeping ${bestItem.pathInfo.folder} (score: ${bestScore})`);
        
        // Create new paths array with only the best item
        const newPaths = [{
            folder: bestItem.pathInfo.folder,
            fullPath: bestItem.pathInfo.fullPath,
            fileObject: bestItem.pathInfo.fileObject
        }];
        
        // Count items being removed
        const originalCount = filePathDatabase[filename].length;
        const removedCount = originalCount - 1;
        
        // Track deleted items for reporting
        plan.delete.concat(plan.keep).forEach(item => {
            if (item !== bestItem) {
                deletedItems.push({
                    filename: filename,
                    folder: item.pathInfo.folder,
                    fullPath: item.pathInfo.fullPath,
                    score: item.score || scoreDuplicateItem(item)
                });
                
                // Remove from audio cache
                if (audioFileCache[item.pathInfo.fullPath]) {
                    delete audioFileCache[item.pathInfo.fullPath];
                }
            }
        });
        
        // Update the database with only the best item
        filePathDatabase[filename] = newPaths;
        deletedCount += removedCount;
        mergedCount++;
        
        console.log(`Merged ${originalCount} variants of ${filename} into 1 (removed ${removedCount})`);
    });
    
    // Clean up completely empty entries (shouldn't happen but just in case)
    Object.keys(filePathDatabase).forEach(filename => {
        if (filePathDatabase[filename].length === 0) {
            delete filePathDatabase[filename];
            console.log(`Removed empty entry: ${filename}`);
        }
    });
    
    // Save changes
    saveFilePathDatabase();
    
    // Update status
    updateStatus(`Intelligente Bereinigung: ${mergedCount} Dateien konsolidiert, ${deletedCount} Duplikate entfernt`);
    
    // Show detailed results
    const resultsMessage = `✅ Intelligente Bereinigung erfolgreich!\n\n` +
        `📊 Statistik:\n` +
        `• ${mergedCount} Dateien konsolidiert (mehrere Pfade → ein bester Pfad)\n` +
        `• ${deletedCount} Duplikate entfernt\n` +
        `• ${Object.keys(filePathDatabase).length} eindeutige Dateien verbleiben\n\n` +
        `🎯 Kriterien für beste Pfade:\n` +
        `• In Projekt vorhanden: +20 Punkte\n` +
        `• Hat EN Text: +10 Punkte\n` +
        `• Hat DE Text: +8 Punkte\n` +
        `• Audio verfügbar: +5 Punkte\n\n` +
        `🔍 Beispiele konsolidiert:\n` +
        deletedItems.slice(0, 5).map(item => 
            `• ${item.filename} (entfernt: ${item.folder.split('/').pop()})`
        ).join('\n') +
        (deletedItems.length > 5 ? `\n... und ${deletedItems.length - 5} weitere` : '');
    
    setTimeout(() => {
        alert(resultsMessage);
        
        // Refresh folder browser if open
        const folderBrowserOpen = document.getElementById('folderBrowserDialog').style.display === 'flex';
        if (folderBrowserOpen) {
            showFolderGrid();
        }
        
        // Refresh main table
        renderFileTable();
    }, 100);
}

        function resetFileDatabase() {
            if (!confirm('Dies löscht die gesamte Datei-Datenbank und alle Ordner-Anpassungen!\nAlle Pfadinformationen und Customizations gehen verloren.\n\nFortfahren?')) {
                return;
            }
            
            filePathDatabase = {};
            audioFileCache = {};
            folderCustomizations = {};
            saveFilePathDatabase();
            saveFolderCustomizations();
            updateStatus('Datei-Datenbank und Ordner-Anpassungen zurückgesetzt. Bitte Ordner neu scannen.');
        updateFileAccessStatus();
        }


// =========================== WAEHLEPROJEKTORDNER START =======================
async function waehleProjektOrdner() {
    try {
        // Nutzer wählt den Wurzelordner aus
        projektOrdnerHandle = await window.showDirectoryPicker();
        await saveProjectFolderHandle(projektOrdnerHandle); // Merken des Ordners

        // DE-Ordner anlegen oder öffnen
        deOrdnerHandle = await projektOrdnerHandle.getDirectoryHandle('DE', { create: true });
        // EN-Ordner anlegen oder öffnen
        enOrdnerHandle = await projektOrdnerHandle.getDirectoryHandle('EN', { create: true });

        enDateien = [];
        deAudioCache = {};

        // Rekursives Einlesen aller Unterordner
        async function leseOrdner(handle, deHandle, pfad = '') {
            for await (const [name, child] of handle.entries()) {
                if (name === 'DE') continue; // DE-Ordner überspringen

                if (child.kind === 'file') {
                    if (name.match(/\.(mp3|wav|ogg)$/i)) {
                        enDateien.push({ pfad: pfad + name, handle: child });
                        if (deHandle) {
                            try {
                                const deFileHandle = await deHandle.getFileHandle(name);
                                const deFile = await deFileHandle.getFile();
                                deAudioCache[pfad + name] = deFile;
                            } catch (e) {
                                // Datei existiert nicht im DE-Ordner
                            }
                        }
                    }
                } else if (child.kind === 'directory') {
                    let neuesDe = null;
                    if (deHandle) {
                        try {
                            neuesDe = await deHandle.getDirectoryHandle(name, { create: false });
                        } catch (e) {
                            // Ordner existiert noch nicht
                            neuesDe = null;
                        }
                    }
                    await leseOrdner(child, neuesDe, pfad + name + '/');
                }
            }
        }

        await leseOrdner(enOrdnerHandle, deOrdnerHandle);

        // Automatischer Scan des EN-Ordners nach der Auswahl
        await scanEnOrdner();

        updateStatus('Projektordner eingelesen und gescannt');
    } catch (e) {
        console.error('Ordnerauswahl fehlgeschlagen:', e);
    }
} 
// =========================== WAEHLEPROJEKTORDNER END =========================

// =========================== STANDARDORDNERAENDERN START ====================
function standardOrdnerAendern() {
    // Öffnet den Dialog zur Wahl eines neuen Standardordners
    waehleProjektOrdner();
}
// =========================== STANDARDORDNERAENDERN END ======================

// =========================== SCANENORDNER START =============================
async function scanEnOrdner() {
    if (!enOrdnerHandle) {
        console.error('EN-Ordner nicht initialisiert');
        return;
    }

    const filesToScan = [];

    async function traverse(handle, path = '') {
        for await (const [name, child] of handle.entries()) {
            if (name === 'DE') continue;

            if (child.kind === 'file') {
                if (name.match(/\.(mp3|wav|ogg)$/i)) {
                    const file = await child.getFile();
                    file.webkitRelativePath = path + name;
                    file.fullPath = path + name;
                    filesToScan.push(file);
                }
            } else if (child.kind === 'directory') {
                await traverse(child, path + name + '/');
            }
        }
    }

    await traverse(enOrdnerHandle);
    if (filesToScan.length > 0) {
        scanFolder({ files: filesToScan });
    }
}
// =========================== SCANENORDNER END ===============================


// =========================== SPEICHEREUEBERSETZUNGSDATEI START ===============
async function speichereUebersetzungsDatei(datei, relativerPfad) {
    if (!deOrdnerHandle) {
        console.error('DE-Ordner nicht initialisiert');
        return;
    }

    const teile = relativerPfad.split('/');
    const dateiname = teile.pop();
    let zielOrdner = deOrdnerHandle;

    for (const teil of teile) {
        zielOrdner = await zielOrdner.getDirectoryHandle(teil, { create: true });
    }

    const fileHandle = await zielOrdner.getFileHandle(dateiname, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(datei);
    await writable.close();

    // DE-Audio im Cache aktualisieren
    deAudioCache[relativerPfad] = datei;
}
// =========================== SPEICHEREUEBERSETZUNGSDATEI END =================

// =========================== INITIATEDEUPLOAD START ==========================
function initiateDeUpload(fileId) {
    const file = files.find(f => f.id === fileId);
    if (!file) return;
    aktuellerUploadPfad = `${file.folder}/${file.filename}`;
    document.getElementById('deUploadInput').click();
}
// =========================== INITIATEDEUPLOAD END ============================

// =========================== HANDLEDEUPLOAD START ============================
async function handleDeUpload(input) {
    const datei = input.files[0];
    if (!datei || !aktuellerUploadPfad) {
        return;
    }
    await speichereUebersetzungsDatei(datei, aktuellerUploadPfad);

    // Zugehörige Datei als fertig markieren
    const file = files.find(f => `${f.folder}/${f.filename}` === aktuellerUploadPfad);
    if (file) {
        file.completed = true;
    }

    aktuellerUploadPfad = null;
    input.value = '';
    renderFileTable();
    updateStatus('DE-Datei gespeichert');
}
// =========================== HANDLEDEUPLOAD END ==============================


// =========================== RENAMEFOLDER START ==============================
async function renameFolder(oldName, newName, parentHandle) {
    const src = await parentHandle.getDirectoryHandle(oldName);
    const dest = await parentHandle.getDirectoryHandle(newName, { create: true });

    // Kopiere alle Inhalte rekursiv
    async function kopiere(srcHandle, destHandle, pfad = '') {
        for await (const [name, child] of srcHandle.entries()) {
            if (child.kind === 'file') {
                const file = await child.getFile();
                const fh = await destHandle.getFileHandle(name, { create: true });
                const w = await fh.createWritable();
                await w.write(file);
                await w.close();
            } else if (child.kind === 'directory') {
                const newDir = await destHandle.getDirectoryHandle(name, { create: true });
                await kopiere(child, newDir, pfad + name + '/');
            }
        }
    }

    await kopiere(src, dest);
    await parentHandle.removeEntry(oldName, { recursive: true });

    aktualisiereDBNachRename(oldName, newName);
}
// =========================== RENAMEFOLDER END ================================


// =========================== AKTUALISIEREDBNACHRENAME START ==================
function aktualisiereDBNachRename(altOrdner, neuOrdner) {
    for (const [filename, paths] of Object.entries(filePathDatabase)) {
        paths.forEach(p => {
            if (p.folder.startsWith(altOrdner)) {
                p.folder = p.folder.replace(altOrdner, neuOrdner);
                p.fullPath = p.fullPath.replace(altOrdner, neuOrdner);
            }
        });
    }

    const neuesTextDB = {};
    for (const [key, val] of Object.entries(textDatabase)) {
        if (key.startsWith(altOrdner + '/')) {
            const neuerKey = neuOrdner + key.slice(altOrdner.length);
            neuesTextDB[neuerKey] = val;
            delete textDatabase[key];
        }
    }
    Object.assign(textDatabase, neuesTextDB);

    saveFilePathDatabase();
    saveTextDatabase();
}
// =========================== AKTUALISIEREDBNACHRENAME END ====================


// =========================== SCANFOLDER IMPROVED START ===========================
function scanFolder(input) {
    const scannedFiles = input.files;
    if (!scannedFiles.length) return;

    const progress     = document.getElementById('scanProgress');
    const progressFill = document.getElementById('progressFill');
    const scanStatus   = document.getElementById('scanStatus');

    progress.classList.add('active');

    let processed         = 0;
    const totalFiles      = scannedFiles.length;
    let duplicatesSkipped = 0;
    let newFilesAdded     = 0;
    let pathsUpdated      = 0;

    const batchSize   = 100;
    let currentBatch  = 0;

    function processBatch() {
        const start = currentBatch * batchSize;
        const end   = Math.min(start + batchSize, totalFiles);

        for (let i = start; i < end; i++) {
            const file     = scannedFiles[i];
            const rawPath  = file.webkitRelativePath;

            // Nur Audio-Dateien
            if (!rawPath.match(/\.(mp3|wav|ogg)$/i)) continue;

            let parts   = rawPath.split('/');
            let lang    = null;

            // Sprache anhand des ersten Unterordners erkennen
            if (parts[0].toUpperCase() === 'DE') {
                lang = 'DE';
                parts.shift();
            } else if (parts[0].toUpperCase() === 'EN') {
                lang = 'EN';
                parts.shift();
            }

            const filename = parts.pop();
            const relPath  = parts.length ? parts.join('/') + '/' + filename : filename;

            if (lang === 'DE') {
                // DE-Dateien nur im Übersetzungs‑Cache speichern
                deAudioCache[relPath] = file;
                continue; // Nicht in die EN-Datenbank aufnehmen
            }

            const folder = extractRelevantFolder(parts, relPath);
            file.fullPath = relPath; // Pfad ohne Sprach-Präfix speichern

            // ---------- VERBESSERTES Duplicate-Handling ----------
            let shouldAdd = true;
            let wasUpdated = false;

            if (filePathDatabase[filename]) {
                // Suche nach EXAKTER Ordner + Pfad Kombination
                const exactIndex = filePathDatabase[filename].findIndex(p =>
                    p.folder === folder && p.fullPath === relPath
                );

                if (exactIndex !== -1) {
                    // EXAKT derselbe Pfad und Ordner → Cache aktualisieren, aber nicht zählen
                    audioFileCache[relPath] = file;
                    duplicatesSkipped++;
                    shouldAdd = false;
                    console.log(`[SCAN] Exact duplicate skipped: ${filename} in ${folder} at ${relPath}`);
                } else {
                    // Suche nach gleichem Ordner aber anderem Pfad
                    const sameFolder = filePathDatabase[filename].findIndex(p => p.folder === folder);
                    
                    if (sameFolder !== -1) {
                        // Gleicher Ordner, anderer Pfad → Pfad aktualisieren
                        const existing = filePathDatabase[filename][sameFolder];
                        console.log(`[SCAN] Updating path for ${filename} in ${folder}: ${existing.fullPath} → ${relPath}`);
                        
                        // Entferne alten Cache-Eintrag
                        if (audioFileCache[existing.fullPath]) {
                            delete audioFileCache[existing.fullPath];
                        }
                        
                        // Aktualisiere Eintrag
                        filePathDatabase[filename][sameFolder] = { folder, fullPath: relPath, fileObject: file };
                        audioFileCache[relPath] = file;
                        pathsUpdated++;
                        shouldAdd = false;
                        wasUpdated = true;
                    }
                    // Wenn kein gleicher Ordner gefunden → Es ist ein neuer Ordner für diese Datei
                    // → shouldAdd bleibt true, neue Datei wird hinzugefügt
                }
            }

            if (shouldAdd) {
                // Neue Datei hinzufügen (neuer Dateiname ODER gleicher Dateiname in neuem Ordner)
                if (!filePathDatabase[filename]) filePathDatabase[filename] = [];
                
                filePathDatabase[filename].push({ folder, fullPath: relPath, fileObject: file });
                audioFileCache[relPath] = file;
                newFilesAdded++;
                
                console.log(`[SCAN] Added: ${filename} in ${folder} (${filePathDatabase[filename].length} total paths for this file)`);
            }

            processed++;
        }

        // Fortschritt aktualisieren
        const percent = Math.round((processed / totalFiles) * 100);
        progressFill.style.width = percent + '%';
        scanStatus.textContent =
            `Verarbeite Datei ${processed} von ${totalFiles}. ` +
            `(${newFilesAdded} neu, ${pathsUpdated} aktualisiert, ${duplicatesSkipped} übersprungen)`;

        currentBatch++;
        if (processed < totalFiles) {
            setTimeout(processBatch, 10);
        } else {
            // ---------------- Nachbearbeitung ----------------
            saveFilePathDatabase();

            // 1. Ordner-Bereinigung (nur leere Ordner ohne Texte)
            const folderCleanup = cleanupMissingFolders(scannedFiles);

            // 2. Datei-Bereinigung (nur Dateien ohne Audio UND ohne Texte)
            const fileCleanup = cleanupMissingFiles(scannedFiles);

            // 3. Projekte synchronisieren
            updateAllProjectsAfterScan();

            // 4. UI-Updates
            setTimeout(() => {
                progress.classList.remove('active');
                
                let statusMsg = `${newFilesAdded} neue Dateien, ${pathsUpdated} Pfade aktualisiert, ${duplicatesSkipped} Duplikate übersprungen`;
                if (folderCleanup.deletedFolders > 0 || fileCleanup > 0) {
                    statusMsg += `, ${folderCleanup.deletedFolders} Ordner & ${fileCleanup} Dateien bereinigt`;
                }
                
                updateStatus(statusMsg);
                updateFileAccessStatus();
                
                // Zeige Zusammenfassung für mehrere Pfade
                const multiPathFiles = Object.entries(filePathDatabase)
                    .filter(([filename, paths]) => paths.length > 1)
                    .length;
                
                if (multiPathFiles > 0) {
                    console.log(`[SCAN] ${multiPathFiles} Dateien haben mehrere Ordner-Pfade (das ist normal für Dateien in verschiedenen Ordnern)`);
                }
                
            }, 500);
        }
    }

    processBatch();
}
// =========================== SCANFOLDER IMPROVED END ===========================

// =========================== IMPROVED IMPORT PROCESS START ===========================
async function startImportProcess() {
    const filenameColumn = parseInt(document.getElementById('filenameColumn').value);
    const englishColumn = parseInt(document.getElementById('englishColumn').value);
    const germanColumn = document.getElementById('germanColumn').value ? parseInt(document.getElementById('germanColumn').value) : -1;
    
    if (isNaN(filenameColumn)) {
        alert('Bitte wählen Sie die Spalte für die Dateinamen aus!');
        return;
    }
    
    if (isNaN(englishColumn)) {
        alert('Bitte wählen Sie die Spalte für den englischen Text aus!');
        return;
    }
    
    if (filenameColumn === englishColumn) {
        alert('Dateinamen und englischer Text können nicht in derselben Spalte sein!');
        return;
    }
    
    if (germanColumn >= 0 && (germanColumn === filenameColumn || germanColumn === englishColumn)) {
        alert('Deutsche Text-Spalte muss unterschiedlich zu den anderen Spalten sein!');
        return;
    }
    
    let imported = 0;
    let updated = 0;
    let notFound = [];
    let multipleFound = [];
    let databaseMatches = 0;
    let skippedDueToAmbiguity = 0;
    
    // Sammle alle Dateien mit mehreren Ordnern für Batch-Auswahl
    const ambiguousFiles = [];
    
    // PHASE 1: Analysiere alle Dateien und sammle mehrdeutige
    parsedImportData.forEach((row, index) => {
        const filename = row[filenameColumn];
        const englishText = row[englishColumn] || '';
        const germanText = germanColumn >= 0 ? (row[germanColumn] || '') : '';
        
        if (!filename || !englishText) {
            return;
        }
        
        // Clean filename
        let cleanFilename = filename.replace(/\.(mp3|wav|ogg)$/i, '');
        
        // Suche nach Datei in Datenbank
        let foundPaths = [];
        
        // Try exact match first
        const extensions = ['.mp3', '.wav', '.ogg'];
        for (const ext of extensions) {
            const fullFilename = cleanFilename + ext;
            if (filePathDatabase[fullFilename]) {
                foundPaths = filePathDatabase[fullFilename].map(pathInfo => ({
                    filename: fullFilename,
                    folder: pathInfo.folder,
                    fullPath: pathInfo.fullPath,
                    pathInfo: pathInfo
                }));
                break;
            }
        }
        
        // Try fuzzy search if not found
        if (foundPaths.length === 0) {
            for (const [dbFilename, paths] of Object.entries(filePathDatabase)) {
                const dbCleanName = dbFilename.replace(/\.(mp3|wav|ogg)$/i, '');
                if (dbCleanName.includes(cleanFilename) || cleanFilename.includes(dbCleanName)) {
                    foundPaths = paths.map(pathInfo => ({
                        filename: dbFilename,
                        folder: pathInfo.folder,
                        fullPath: pathInfo.fullPath,
                        pathInfo: pathInfo
                    }));
                    break;
                }
            }
        }
        
        if (foundPaths.length === 0) {
            notFound.push(filename);
        } else if (foundPaths.length === 1) {
            // Eindeutig → direkt verarbeiten
            const match = foundPaths[0];
            updateTextDatabase(match.filename, match.pathInfo, englishText, germanText);
            imported++;
            databaseMatches++;
        } else {
            // Mehrdeutig → zur späteren Auswahl sammeln
            ambiguousFiles.push({
                originalFilename: filename,
                englishText: englishText,
                germanText: germanText,
                foundPaths: foundPaths,
                rowIndex: index
            });
        }
    });
    
    // PHASE 2: Benutzer-Auswahl für mehrdeutige Dateien
    if (ambiguousFiles.length > 0) {
        const selections = await showFolderSelectionDialog(ambiguousFiles);
        
        if (selections === null) {
            // Benutzer hat abgebrochen
            alert('Import abgebrochen.');
            return;
        }
        
        // Verarbeite Benutzer-Auswahlen
        selections.forEach((selection, index) => {
            if (selection.selectedIndex >= 0) {
                const ambiguous = ambiguousFiles[index];
                const selectedPath = ambiguous.foundPaths[selection.selectedIndex];
                
                updateTextDatabase(selectedPath.filename, selectedPath.pathInfo, ambiguous.englishText, ambiguous.germanText);
                imported++;
                databaseMatches++;
                multipleFound.push({
                    original: ambiguous.originalFilename,
                    selected: selectedPath.folder
                });
            } else {
                skippedDueToAmbiguity++;
                notFound.push(ambiguousFiles[index].originalFilename);
            }
        });
    }
    
    // PHASE 3: Update current project files
    files.forEach(file => {
        const fileKey = `${file.folder}/${file.filename}`;
        if (textDatabase[fileKey]) {
            let wasUpdated = false;
            if (textDatabase[fileKey].en && textDatabase[fileKey].en !== file.enText) {
                file.enText = textDatabase[fileKey].en;
                wasUpdated = true;
            }
            if (textDatabase[fileKey].de && textDatabase[fileKey].de !== file.deText) {
                file.deText = textDatabase[fileKey].de;
                wasUpdated = true;
            }
            if (wasUpdated) {
                updated++;
            }
        }
    });
    
    if (imported > 0 || updated > 0) {
        isDirty = true;
        saveTextDatabase();
        if (updated > 0) {
            renderFileTable();
            updateProgressStats();
        }
        
        let message = `${imported} Texte in die Datenbank importiert`;
        if (updated > 0) {
            message += `\n${updated} Dateien im aktuellen Projekt aktualisiert`;
        }
        
        updateStatus(message);
        closeImportDialog();
        
        // Erweiterte Erfolgs-Nachricht
        let summaryMessage = `✅ Import erfolgreich abgeschlossen!\n\n` +
            `📊 Statistik:\n` +
            `• ${imported} Texte importiert (${databaseMatches} DB-Matches)\n` +
            `• ${updated} Projekt-Dateien aktualisiert\n` +
            `• ${parsedImportData.length} Zeilen verarbeitet\n` +
            `• ${notFound.length} nicht gefunden\n`;
            
        if (multipleFound.length > 0) {
            summaryMessage += `• ${multipleFound.length} mehrdeutige Dateien aufgelöst\n`;
        }
        if (skippedDueToAmbiguity > 0) {
            summaryMessage += `• ${skippedDueToAmbiguity} mehrdeutige Dateien übersprungen\n`;
        }
        
        summaryMessage += `\n🎯 Spalten-Zuordnung:\n` +
            `• Dateinamen: Spalte ${filenameColumn + 1}\n` +
            `• Englisch: Spalte ${englishColumn + 1}\n` +
            `• Deutsch: ${germanColumn >= 0 ? `Spalte ${germanColumn + 1}` : 'Nicht verwendet'}`;
        
        if (multipleFound.length > 0) {
            summaryMessage += `\n\n🎯 Ordner-Auswahlen:\n` +
                multipleFound.slice(0, 5).map(mf => `• ${mf.original} → ${mf.selected}`).join('\n') +
                (multipleFound.length > 5 ? `\n... und ${multipleFound.length - 5} weitere` : '');
        }
        
        setTimeout(() => {
            alert(summaryMessage + (notFound.length > 0 && notFound.length <= 10 ? `\n\n❌ Nicht gefunden:\n${notFound.join('\n')}` : 
                  notFound.length > 10 ? `\n\n❌ ${notFound.length} Dateien nicht gefunden (erste 5):\n${notFound.slice(0, 5).join('\n')}\n...` : ''));
        }, 100);
    } else {
        alert('❌ Keine Dateien konnten importiert werden!\n\n' +
              'Mögliche Gründe:\n' +
              '1. Dateien wurden nicht in der Datenbank gefunden\n' +
              '2. Falsche Spalten-Zuordnung\n' +
              '3. Leere oder ungültige Daten\n' +
              '4. Alle mehrdeutigen Dateien wurden übersprungen\n\n' +
              `📊 Versucht: ${parsedImportData.length} Zeilen\n` +
              `❌ Nicht gefunden: ${notFound.length}\n` +
              `❓ Mehrdeutig übersprungen: ${skippedDueToAmbiguity}\n\n` +
              'Tipp: Scannen Sie zuerst den Ordner mit den Audio-Dateien.');
    }
}

// =========================== FOLDER SELECTION DIALOG START ===========================
function showFolderSelectionDialog(ambiguousFiles) {
    return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'dialog-overlay';
        overlay.style.display = 'flex';
        
        const dialog = document.createElement('div');
        dialog.className = 'dialog';
        dialog.style.maxWidth = '800px';
        dialog.style.maxHeight = '80vh';
        dialog.style.overflow = 'auto';
        
        const selections = new Array(ambiguousFiles.length).fill(null).map(() => ({ selectedIndex: -1 }));
        
        dialog.innerHTML = `
            <h3>📁 Ordner-Auswahl für mehrdeutige Dateien</h3>
            <p style="margin-bottom: 20px; color: #999;">
                Die folgenden Dateien wurden in mehreren Ordnern gefunden. 
                Bitte wählen Sie den passenden Ordner für jede Datei aus:
            </p>
            
            <!-- NEUE OPTION: Auswahl übertragen -->
            <div style="background: #2a2a2a; padding: 15px; margin: 0 0 20px 0; border-radius: 6px; border: 2px solid #ff6b1a;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="applyToAll" style="width: 18px; height: 18px;">
                    <strong style="color: #ff6b1a;">🔄 Erste Auswahl auf alle folgenden Dateien übertragen</strong>
                </label>
                <p style="margin: 8px 0 0 28px; font-size: 12px; color: #999;">
                    Wenn aktiviert, wird die erste Ordner-Auswahl automatisch für alle weiteren Dateien verwendet.
                </p>
            </div>
            
            <div id="folderSelectionList" style="max-height: 400px; overflow-y: auto;">
                ${ambiguousFiles.map((item, index) => `
                    <div id="fileItem_${index}" style="background: #1a1a1a; border: 1px solid #444; border-radius: 6px; padding: 15px; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="color: #ff6b1a; font-weight: bold; margin-bottom: 10px;">
                                📄 ${item.originalFilename}
                            </div>
                            <div id="autoApplied_${index}" style="display: none; background: #4caf50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">
                                ✅ Auto-übertragen
                            </div>
                        </div>
                        <div style="color: #999; font-size: 12px; margin-bottom: 15px;">
                            EN: ${item.englishText.length > 60 ? item.englishText.substring(0, 60) + '...' : item.englishText}
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>Gefunden in ${item.foundPaths.length} Ordnern:</strong>
                        </div>
                        ${item.foundPaths.map((path, pathIndex) => {
                            const folderName = path.folder.split('/').pop() || path.folder;
                            const hasAudio = !!audioFileCache[path.fullPath];
                            return `
                                <label id="folderOption_${index}_${pathIndex}" style="display: block; padding: 8px; margin: 5px 0; background: #2a2a2a; border-radius: 4px; cursor: pointer; border: 1px solid #333;" 
                                       onclick="selectFolder(${index}, ${pathIndex})">
                                    <input type="radio" name="folder_${index}" value="${pathIndex}" style="margin-right: 10px;">
                                    <span style="color: #4caf50;">${hasAudio ? '🎵' : '❓'}</span>
                                    <strong>${folderName}</strong>
                                    <br>
                                    <small style="color: #666; margin-left: 25px;">${path.folder}</small>
                                    ${!hasAudio ? '<br><small style="color: #f44336; margin-left: 25px;">⚠️ Audio nicht im Cache</small>' : ''}
                                </label>
                            `;
                        }).join('')}
                        <label id="skipOption_${index}" style="display: block; padding: 8px; margin: 5px 0; background: #333; border-radius: 4px; cursor: pointer; border: 1px solid #666;" 
                               onclick="selectFolder(${index}, -1)">
                            <input type="radio" name="folder_${index}" value="-1" style="margin-right: 10px;">
                            <span style="color: #f44336;">❌ Überspringen</span>
                        </label>
                    </div>
                `).join('')}
            </div>
            <div style="background: #2a2a2a; padding: 15px; margin: 20px 0; border-radius: 6px;">
                <strong>🎯 Auswahlhilfen:</strong><br>
                • 🎵 = Audio-Datei ist verfügbar<br>
                • ❓ = Audio-Datei nicht im Cache<br>
                • 🔄 = Auswahl wurde automatisch übertragen<br>
                • Wählen Sie den Ordner, der zum Kontext des Textes passt<br>
                • "Überspringen" ignoriert diese Datei beim Import
            </div>
            <div class="dialog-buttons">
                <button class="btn btn-secondary" onclick="cancelFolderSelection()">Alle überspringen</button>
                <button class="btn btn-success" onclick="confirmFolderSelection()">Auswahl bestätigen</button>
            </div>
        `;
        
        let firstSelectionMade = false;
        let firstSelectedPath = null;
        
        // Global functions for the dialog
        window.selectFolder = (fileIndex, pathIndex) => {
            selections[fileIndex].selectedIndex = pathIndex;
            console.log(`Selected folder ${pathIndex} for file ${fileIndex}`);
            
            // Visuelles Feedback
            const fileItem = document.getElementById(`fileItem_${fileIndex}`);
            if (fileItem) {
                // Entferne alte Auswahl-Highlights
                fileItem.querySelectorAll('label').forEach(label => {
                    label.style.borderColor = label.id.includes('skipOption') ? '#666' : '#333';
                    label.style.background = label.id.includes('skipOption') ? '#333' : '#2a2a2a';
                });
                
                // Highlight ausgewählte Option
                if (pathIndex >= 0) {
                    const selectedLabel = document.getElementById(`folderOption_${fileIndex}_${pathIndex}`);
                    if (selectedLabel) {
                        selectedLabel.style.borderColor = '#4caf50';
                        selectedLabel.style.background = '#1a3a1a';
                    }
                } else {
                    const skipLabel = document.getElementById(`skipOption_${fileIndex}`);
                    if (skipLabel) {
                        skipLabel.style.borderColor = '#f44336';
                        skipLabel.style.background = '#3a1a1a';
                    }
                }
            }
            
            // Prüfe ob "Auf alle übertragen" aktiviert ist
            const applyToAll = document.getElementById('applyToAll');
            if (applyToAll && applyToAll.checked && !firstSelectionMade && fileIndex === 0) {
                firstSelectionMade = true;
                firstSelectedPath = pathIndex;
                
                // Übertrage die Auswahl auf alle anderen Dateien
                for (let i = 1; i < ambiguousFiles.length; i++) {
                    // Finde den passenden Ordner in den anderen Dateien
                    let matchingPathIndex = -1;
                    
                    if (pathIndex >= 0) {
                        const selectedFolder = ambiguousFiles[0].foundPaths[pathIndex].folder;
                        
                        // Suche nach dem gleichen Ordner in der aktuellen Datei
                        matchingPathIndex = ambiguousFiles[i].foundPaths.findIndex(
                            path => path.folder === selectedFolder
                        );
                        
                        // Wenn nicht gefunden, versuche Teilübereinstimmung
                        if (matchingPathIndex === -1) {
                            const selectedFolderParts = selectedFolder.split('/');
                            const selectedLastPart = selectedFolderParts[selectedFolderParts.length - 1];
                            
                            matchingPathIndex = ambiguousFiles[i].foundPaths.findIndex(
                                path => path.folder.endsWith(selectedLastPart)
                            );
                        }
                    }
                    
                    // Setze die Auswahl
                    selections[i].selectedIndex = matchingPathIndex >= 0 ? matchingPathIndex : pathIndex;
                    
                    // Visuelles Feedback
                    const autoIndicator = document.getElementById(`autoApplied_${i}`);
                    if (autoIndicator) {
                        autoIndicator.style.display = 'block';
                    }
                    
                    // Setze Radio-Button
                    const radioToCheck = document.querySelector(`input[name="folder_${i}"][value="${selections[i].selectedIndex}"]`);
                    if (radioToCheck) {
                        radioToCheck.checked = true;
                    }
                    
                    // Highlight die automatisch ausgewählte Option
                    const itemDiv = document.getElementById(`fileItem_${i}`);
                    if (itemDiv) {
                        itemDiv.style.borderColor = '#4caf50';
                        itemDiv.style.borderWidth = '2px';
                        
                        if (selections[i].selectedIndex >= 0) {
                            const autoSelectedLabel = document.getElementById(`folderOption_${i}_${selections[i].selectedIndex}`);
                            if (autoSelectedLabel) {
                                autoSelectedLabel.style.borderColor = '#4caf50';
                                autoSelectedLabel.style.background = '#1a3a1a';
                            }
                        } else {
                            const skipLabel = document.getElementById(`skipOption_${i}`);
                            if (skipLabel) {
                                skipLabel.style.borderColor = '#f44336';
                                skipLabel.style.background = '#3a1a1a';
                            }
                        }
                    }
                }
                
                // Zeige Erfolgsmeldung
                const message = pathIndex >= 0 ? 
                    `✅ Ordner "${ambiguousFiles[0].foundPaths[pathIndex].folder}" wurde auf alle ${ambiguousFiles.length - 1} weiteren Dateien übertragen.` :
                    `❌ "Überspringen" wurde auf alle ${ambiguousFiles.length - 1} weiteren Dateien übertragen.`;
                
                const msgDiv = document.createElement('div');
                msgDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4caf50; color: white; padding: 15px 20px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 3000;';
                msgDiv.textContent = message;
                document.body.appendChild(msgDiv);
                
                setTimeout(() => {
                    msgDiv.remove();
                }, 3000);
            }
        };
        
        window.cancelFolderSelection = () => {
            document.body.removeChild(overlay);
            resolve(null);
        };
        
        window.confirmFolderSelection = () => {
            // Zähle Auswahlen
            const selectedCount = selections.filter(s => s.selectedIndex >= 0).length;
            const skippedCount = selections.filter(s => s.selectedIndex === -1).length;
            const unselectedCount = selections.filter(s => s.selectedIndex < -1).length;
            
            if (unselectedCount > 0) {
                if (!confirm(`${unselectedCount} Dateien haben keine Auswahl.\nDiese werden übersprungen.\n\nFortfahren?`)) {
                    return;
                }
                // Setze unausgewählte auf "überspringen"
                selections.forEach(s => {
                    if (s.selectedIndex < -1) s.selectedIndex = -1;
                });
            }
            
            document.body.removeChild(overlay);
            resolve(selections);
        };
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Cleanup functions when dialog closes
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                window.cancelFolderSelection();
            }
        });
    });
}
// =========================== FOLDER SELECTION DIALOG END ===========================

function updateTextDatabase(filename, pathInfo, englishText, germanText) {
    const fileKey = `${pathInfo.folder}/${filename}`;
    if (!textDatabase[fileKey]) {
        textDatabase[fileKey] = {};
    }
    
    if (englishText) {
        textDatabase[fileKey].en = englishText;
    }
    if (germanText) {
        textDatabase[fileKey].de = germanText;
    }
    
    console.log(`[IMPORT] Updated text for ${fileKey}: EN=${!!englishText}, DE=${!!germanText}`);
}
// =========================== IMPROVED IMPORT PROCESS END ===========================



// =========================== IMPROVED SEARCH FUNCTION START ===========================
async function addFromSearch(result) {
    // Prüfe ob Datei bereits im Projekt ist
    const existingFile = files.find(f => f.filename === result.filename && f.folder === result.folder);
    if (existingFile) {
        updateStatus('Datei bereits im Projekt');
        return;
    }
    
    // Prüfe ob es mehrere Ordner für diese Datei gibt
    if (filePathDatabase[result.filename] && filePathDatabase[result.filename].length > 1) {
        console.log(`[SEARCH] Multiple folders found for ${result.filename}, showing selection dialog`);
        
        const paths = filePathDatabase[result.filename];
        const selection = await showSingleFileSelectionDialog(result.filename, paths, result);
        
        if (selection === null) {
            updateStatus('Hinzufügen abgebrochen');
            return;
        }
        
        // Verwende ausgewählten Pfad
        const selectedPath = paths[selection.selectedIndex];
        addFileToProject(result.filename, selectedPath.folder, selectedPath.fullPath, result);
    } else {
        // Nur ein Pfad oder bereits spezifischer Pfad aus Suchergebnis
        addFileToProject(result.filename, result.folder, result.fullPath, result);
    }
}


// =========================== showSingleFileSelectionDialog START ===========================
function showSingleFileSelectionDialog(filename, paths, originalResult) {
    return new Promise((resolve) => {
        // Wenn nur ein Pfad vorhanden, direkt verwenden
        if (paths.length === 1) {
            resolve({ selectedIndex: 0 });
            return;
        }
        
        const overlay = document.createElement('div');
        overlay.className = 'dialog-overlay';
        overlay.style.display = 'flex';
        
        const dialog = document.createElement('div');
        dialog.className = 'dialog';
        dialog.style.maxWidth = '600px';
        
        let selectedIndex = -1;
        
        // Versuche intelligente Vorauswahl basierend auf dem Suchergebnis
        if (originalResult && originalResult.folder) {
            const exactMatch = paths.findIndex(p => p.folder === originalResult.folder);
            if (exactMatch >= 0) {
                selectedIndex = exactMatch;
            }
        }
        
        dialog.innerHTML = `
            <h3>📁 Ordner auswählen</h3>
            <p style="margin-bottom: 20px; color: #999;">
                Die Datei <strong>${filename}</strong> wurde in mehreren Ordnern gefunden.<br>
                Bitte wählen Sie den passenden Ordner aus:
            </p>
            <div style="max-height: 300px; overflow-y: auto;">
                ${paths.map((pathInfo, index) => {
                    const folderName = pathInfo.folder.split('/').pop() || pathInfo.folder;
                    const hasAudio = !!audioFileCache[pathInfo.fullPath];
                    const isPreselected = index === selectedIndex;
                    return `
                        <label style="
                            display: flex; 
                            align-items: center; 
                            justify-content: space-between; 
                            padding: 12px; 
                            margin: 8px 0; 
                            background: ${isPreselected ? '#ff6b1a' : '#2a2a2a'}; 
                            border-radius: 6px; 
                            cursor: pointer; 
                            border: 2px solid ${isPreselected ? '#ff6b1a' : '#333'};
                        " onclick="selectSingleFolder(${index})">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input 
                                    type="radio" 
                                    name="singleFolder" 
                                    value="${index}" 
                                    ${isPreselected ? 'checked' : ''} 
                                    style="margin-right: 10px;"
                                >
                                <span style="font-size: 16px; color: ${hasAudio ? '#4caf50' : '#f44336'};">
                                    ${hasAudio ? '🎵' : '❓'}
                                </span>
                                <div>
                                    <strong style="color: ${isPreselected ? '#fff' : '#ff6b1a'};">
                                        ${folderName}
                                    </strong><br>
                                    <small style="color: ${isPreselected ? '#fff' : '#666'};">
                                        ${pathInfo.folder}
                                    </small>
                                    ${!hasAudio ? `<br><small style="color: #f44336;">⚠️ Audio nicht verfügbar</small>` : ''}
                                </div>
                            </div>
                            <div>
                                <button 
                                    class="play-btn" 
                                    ${hasAudio ? '' : 'disabled'} 
                                    onclick="event.stopPropagation(); playPreview('${pathInfo.fullPath}')"
                                    title="${hasAudio ? 'Audio abspielen' : 'Audio nicht verfügbar'}"
                                >▶</button>
                            </div>
                        </label>
                    `;
                }).join('')}
            </div>
            <div style="
                background: #1a1a1a; 
                padding: 12px; 
                margin: 15px 0; 
                border-radius: 6px; 
                font-size: 13px; 
                color: #999;
            ">
                💡 <strong>Auswahlhilfe:</strong><br>
                • 🎵 = Audio-Datei ist verfügbar<br>
                • ❓ = Audio-Datei nicht im Cache<br>
                • Wählen Sie den Ordner, der zu Ihrem Projekt passt
            </div>
            <div class="dialog-buttons">
                <button class="btn btn-secondary" onclick="cancelSingleSelection()">Abbrechen</button>
                <button class="btn btn-success" onclick="confirmSingleSelection()" ${selectedIndex >= 0 ? '' : 'disabled'}>
                    Hinzufügen
                </button>
            </div>
        `;
        
        // Globale Funktionen für den Dialog
        window.selectSingleFolder = (index) => {
            selectedIndex = index;
            // Visuelle Auswahl aktualisieren
            dialog.querySelectorAll('label').forEach((label, i) => {
                const isSel = (i === index);
                label.style.background = isSel ? '#ff6b1a' : '#2a2a2a';
                label.style.borderColor = isSel ? '#ff6b1a' : '#333';
                
                const strong = label.querySelector('strong');
                const smalls = label.querySelectorAll('small');
                if (strong) strong.style.color = isSel ? '#fff' : '#ff6b1a';
                smalls.forEach(s => {
                    if (!s.textContent.includes('Audio nicht verfügbar')) {
                        s.style.color = isSel ? '#fff' : '#666';
                    }
                });
                
                const radio = label.querySelector('input[type="radio"]');
                if (radio) radio.checked = isSel;
            });
            
            // Confirm-Button aktivieren
            const confirmBtn = dialog.querySelector('.btn-success');
            if (confirmBtn) confirmBtn.disabled = false;
        };
        
        window.cancelSingleSelection = () => {
            document.body.removeChild(overlay);
            resolve(null);
        };
        
        window.confirmSingleSelection = () => {
            if (selectedIndex >= 0) {
                document.body.removeChild(overlay);
                resolve({ selectedIndex: selectedIndex });
            }
        };
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Klick außerhalb abfangen und abbrechen
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                window.cancelSingleSelection();
            }
        });
    });
}
// =========================== showSingleFileSelectionDialog END ===========================

// =========================== playPreview START ===========================
function playPreview(fullPath) {
    const audioPlayer = document.getElementById('audioPlayer');
    const fileObj = audioFileCache[fullPath];
    if (fileObj) {
        try {
            // Erzeuge eine temporäre URL aus dem File-Objekt und setze sie auf den Audio-Player
            const url = URL.createObjectURL(fileObj);
            audioPlayer.src = url;
            audioPlayer.play().catch(err => {
                alert('Abspielen fehlgeschlagen: ' + err.message);
            });
        } catch (e) {
            alert('Fehler beim Erzeugen der Audio-URL: ' + e.message);
        }
    } else {
        alert('⚠️ Audio-Datei nicht im Cache verfügbar');
    }
}
// =========================== playPreview END ===========================



// Hilfsfunktion zum Hinzufügen einer Datei zum Projekt
function addFileToProject(filename, folder, fullPath, originalResult) {
    const fileKey = `${folder}/${filename}`;
    const newFile = {
        id: Date.now() + Math.random(),
        filename: filename,
        folder: folder,
        // fullPath wird NICHT mehr gespeichert - wird dynamisch geladen
        enText: textDatabase[fileKey]?.en || '',
        deText: textDatabase[fileKey]?.de || '',
        selected: true,
        completed: false
    };
    
    files.push(newFile);
    
    // Update display order for new file
    displayOrder.push({ file: newFile, originalIndex: files.length - 1 });
    
    isDirty = true;
    renderFileTable();
    renderProjects(); // Live Update
    updateProgressStats();
    
    const folderName = folder.split('/').pop() || folder;
    updateStatus(`${filename} aus Ordner "${folderName}" zum Projekt hinzugefügt`);
    
    // Close search results
    document.getElementById('searchInput').value = '';
    document.getElementById('searchResults').style.display = 'none';
}
// =========================== IMPROVED SEARCH FUNCTION END ===========================

// =========================== IGNOREDFILES VAR START ===========================
let ignoredFiles = {};               // fileKey -> true

function loadIgnoredFiles() {
    try {
        const raw = localStorage.getItem('ignoredFiles');
        ignoredFiles = raw ? JSON.parse(raw) : {};
    } catch (e) {
        ignoredFiles = {};
    }
}

function saveIgnoredFiles() {
    localStorage.setItem('ignoredFiles', JSON.stringify(ignoredFiles));
}

// Beim Start laden
loadIgnoredFiles();
// =========================== IGNOREDFILES VAR END ===========================

// =========================== TOGGLESKIPFILE START ===========================
function toggleSkipFile(folder, filename) {
    const fileKey = `${folder}/${filename}`;

    if (ignoredFiles[fileKey]) {
        delete ignoredFiles[fileKey];
        console.log(`[IGNORED] Aufgehoben: ${fileKey}`);
    } else {
        ignoredFiles[fileKey] = true;
        console.log(`[IGNORED] Markiert: ${fileKey}`);
    }

    saveIgnoredFiles();

    // UI & Statistiken sofort aktualisieren
    showFolderFiles(folder);          // aktuelle Ansicht neu rendern
    refreshGlobalStatsAndGrids();     // eigene Hilfs-Funktion, s. ganz unten
}
// =========================== TOGGLESKIPFILE END ===========================




		
		
		

        // Project Drag and Drop
        let draggedProject = null;

        function handleProjectDragStart(e) {
            draggedProject = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleProjectDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleProjectDragEnter(e) {
            if (e.target !== draggedProject) {
                e.target.classList.add('drag-over');
            }
        }

        function handleProjectDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleProjectDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            e.target.classList.remove('drag-over');
            
            if (draggedProject !== e.target) {
                const draggedId = parseInt(draggedProject.dataset.projectId);
                const targetId = parseInt(e.target.dataset.projectId);
                
                const draggedIndex = projects.findIndex(p => p.id === draggedId);
                const targetIndex = projects.findIndex(p => p.id === targetId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    // Remove dragged project from array
                    const draggedProjectObj = projects.splice(draggedIndex, 1)[0];
                    
                    // Insert at new position
                    projects.splice(targetIndex, 0, draggedProjectObj);
                    
                    // Save and re-render
                    saveProjects();
                    renderProjects();
                    
                    // Maintain active project selection
                    document.querySelectorAll('.project-item').forEach(item => {
                        item.classList.toggle('active', item.dataset.projectId == currentProject?.id);
                    });
                    
                    updateStatus('Projekt-Reihenfolge geändert');
                }
            }
            
            return false;
        }

        function handleProjectDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedProject = null;
        }

/* =========================== SHOW PROJECT CUSTOMIZATION START =========================== */
function showProjectCustomization(id, ev) {
    ev?.stopPropagation();
    const prj = projects.find(p => p.id === id);
    if (!prj) return;

    const knownLevels = [...new Set(projects.map(p => p.levelName).filter(Boolean))];

    const ov = document.createElement('div');
    ov.className = 'customize-popup-overlay';
    ov.onclick   = () => document.body.removeChild(ov);

    const pop = document.createElement('div');
    pop.className = 'folder-customize-popup';
    pop.onclick   = e => e.stopPropagation();

    pop.innerHTML = `
      <h4>⚙️ Projekt-Einstellungen</h4>

      <div class="customize-field">
        <label>Projektname:</label>
        <input id="cName" value="${prj.name}">
      </div>

      <div class="customize-field">
        <label>Level-Name:</label>
        <select id="cLevel">
          <option value="">– neu –</option>
          ${knownLevels.map(l => `<option ${l===prj.levelName?'selected':''}>${l}</option>`).join('')}
        </select>
        <input id="cLevelNew"
               placeholder="Neuen Level-Namen"
               style="margin-top:8px;display:${prj.levelName?'none':'block'};">
      </div>

      <div class="customize-field">
        <label>Teil-Nummer:</label>
        <input type="number" id="cPart" min="1" max="99" value="${prj.levelPart}">
      </div>

      <div class="customize-field">
        <label>Farbe (Level-weit):</label>
        <input type="color" id="cColor" value="${getLevelColor(prj.levelName)}">
      </div>

      <div class="customize-buttons">
        <button class="btn btn-secondary" id="cCancel">Abbrechen</button>
        <button class="btn btn-success"   id="cSave">Speichern</button>
      </div>
    `;

    ov.appendChild(pop);
    document.body.appendChild(ov);

    /* Eingabedynamik */
    const sel = pop.querySelector('#cLevel');
    const inp = pop.querySelector('#cLevelNew');
    sel.onchange = () => {
        inp.style.display = sel.value ? 'none' : 'block';
    };

    pop.querySelector('#cCancel').onclick = () => document.body.removeChild(ov);

    pop.querySelector('#cSave').onclick = () => {
        prj.name      = pop.querySelector('#cName').value.trim() || prj.name;
        prj.levelName = sel.value || inp.value.trim();
        prj.levelPart = Math.max(1, parseInt(pop.querySelector('#cPart').value) || 1);

        /* Level-Farbe global anwenden */
        const newColor = pop.querySelector('#cColor').value;
        setLevelColor(prj.levelName, newColor);

        saveProjects();
        updateProjectMetaBar();
        document.body.removeChild(ov);
    };
}
/* =========================== SHOW PROJECT CUSTOMIZATION END =========================== */




        function updateProjectCustomizationPreview() {
            const iconInput = document.getElementById('customProjectIcon');
            const colorInput = document.getElementById('customProjectColor');
            const iconPreview = document.getElementById('projectIconPreview');
            const colorPreview = document.getElementById('projectColorPreview');
            
            if (iconInput && iconPreview) {
                iconPreview.textContent = iconInput.value || '🗂️';
            }
            
            if (colorInput && colorPreview) {
                colorPreview.style.background = colorInput.value;
            }
        }
		
		

        function applyProjectPreset(projectId) {
            const presetSelect = document.getElementById('projectPresetSelect');
            const iconInput = document.getElementById('customProjectIcon');
            const colorInput = document.getElementById('customProjectColor');
            
            const presets = {
                'game': { icon: '🎮', color: '#ff6b1a' },
                'work': { icon: '💼', color: '#1976d2' },
                'personal': { icon: '👤', color: '#388e3c' },
                'translation': { icon: '🌐', color: '#7b1fa2' },
                'audio': { icon: '🎵', color: '#d32f2f' },
                'archive': { icon: '📦', color: '#616161' },
                'test': { icon: '🧪', color: '#f57c00' },
                'backup': { icon: '💾', color: '#2e7d32' },
                'folder': { icon: '🗂️', color: '#333333' }
            };
            
            const preset = presets[presetSelect.value];
            if (preset) {
                iconInput.value = preset.icon;
                colorInput.value = preset.color;
                updateProjectCustomizationPreview();
            }
        }

        function saveProjectCustomization(projectId) {
            const iconInput = document.getElementById('customProjectIcon');
            const colorInput = document.getElementById('customProjectColor');
            
            const project = projects.find(p => p.id === projectId);
            if (project) {
                project.icon = iconInput.value || '🗂️';
                project.color = colorInput.value || '#333333';
                
                saveProjects();
                renderProjects();
                
                // Maintain active selection
                document.querySelectorAll('.project-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.projectId == currentProject?.id);
                });
                
                closeProjectCustomization();
                updateStatus('Projekt-Anpassung gespeichert');
            }
        }

        function resetProjectCustomization(projectId) {
            if (confirm('Möchten Sie die Anpassungen für dieses Projekt wirklich zurücksetzen?')) {
                const project = projects.find(p => p.id === projectId);
                if (project) {
                    project.icon = '🗂️';
                    project.color = '#333333';
                    
                    saveProjects();
                    renderProjects();
                    
                    // Maintain active selection
                    document.querySelectorAll('.project-item').forEach(item => {
                        item.classList.toggle('active', item.dataset.projectId == currentProject?.id);
                    });
                    
                    closeProjectCustomization();
                    updateStatus('Projekt-Anpassung zurückgesetzt');
                }
            }
        }

        function closeProjectCustomization() {
            const overlay = document.querySelector('.customize-popup-overlay');
            const popup = document.querySelector('.folder-customize-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        // File Drag and Drop
        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const afterElement = getDragAfterElement(e.currentTarget.parentNode, e.clientY);
            if (afterElement == null) {
                e.currentTarget.parentNode.appendChild(draggedElement);
            } else {
                e.currentTarget.parentNode.insertBefore(draggedElement, afterElement);
            }
            
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const draggedId = parseFloat(draggedElement.dataset.id);
            const draggedIndex = files.findIndex(f => f.id === draggedId);
            const draggedFile = files[draggedIndex];
            
            files.splice(draggedIndex, 1);
            
            const rows = Array.from(document.querySelectorAll('#fileTableBody tr'));
            const newIndex = rows.indexOf(draggedElement);
            
            files.splice(newIndex, 0, draggedFile);
            
            // Reset display order to reflect new order
            displayOrder = files.map((file, index) => ({ file, originalIndex: index }));
            
            isDirty = true;
            renderFileTable();
            
            return false;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('tr:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Status updates
        function updateStatus(message) {
            const statusText = document.getElementById('statusText');
            if (message) {
                statusText.textContent = message;
                setTimeout(() => {
                    statusText.textContent = isDirty ? 'Ungespeicherte Änderungen' : 'Bereit';
                }, 3000);
            } else {
                statusText.textContent = isDirty ? 'Ungespeicherte Änderungen' : 'Bereit';
            }
        }

        function updateCounts() {
            const fileCount = document.getElementById('fileCount');
            const selectedCount = document.getElementById('selectedCount');
            
            fileCount.textContent = `${files.length} Dateien`;
            selectedCount.textContent = `${files.filter(f => f.selected).length} ausgewählt`;
            
            updateFileAccessStatus();
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-save on input changes with debouncing
        let saveTimeout;
        document.addEventListener('input', (e) => {
            if (e.target.classList.contains('text-input')) {
                // Auto-resize the input (height)
                autoResizeInput(e.target);
                
                // Debounced save
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveCurrentProject();
                }, 1000);
            }
        });

        // Additional events for better text area handling
        document.addEventListener('keyup', (e) => {
            if (e.target.classList.contains('text-input')) {
                autoResizeInput(e.target);
            }
        });

        document.addEventListener('paste', (e) => {
            if (e.target.classList.contains('text-input')) {
                // Small delay to let paste complete
                setTimeout(() => {
                    autoResizeInput(e.target);
                }, 10);
            }
        });

        // Double-click to edit project name or change row numbers
        document.addEventListener('dblclick', (e) => {
            const projectItem = e.target.closest('.project-item');
            if (projectItem && !e.target.classList.contains('delete-btn') && !e.target.classList.contains('project-customize-btn')) {
                const projectId = parseInt(projectItem.dataset.projectId);
                const project = projects.find(p => p.id === projectId);
                if (project) {
                    const newName = prompt('Projekt umbenennen:', project.name);
                    if (newName && newName !== project.name) {
                        project.name = newName;
                        saveProjects();
                        renderProjects();
                        document.querySelectorAll('.project-item').forEach(item => {
                            item.classList.toggle('active', item.dataset.projectId == projectId);
                        });
                    }
                }
            }
        });

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Fehler:', e);
            updateStatus('Ein Fehler ist aufgetreten');
        });

        // Window resize handling for text inputs
        window.addEventListener('resize', () => {
            setTimeout(() => {
                autoResizeAllInputs();
            }, 100);
        });

        // Initialize app
        console.log('%c🎮 Half-Life: Alyx Translation Tool geladen!', 'color: #ff6b1a; font-size: 16px; font-weight: bold;');
        console.log('Version 3.6.0 Level-Management & Datenbank-Tools Edition');
        console.log('✨ NEUE FEATURES:');
        console.log('• 📊 Globale Übersetzungsstatistiken: Projekt-übergreifendes Completion-Tracking');
        console.log('• 🟢 Ordner-Completion-Status: Grüne Rahmen für vollständig übersetzte Ordner');
        console.log('• ✅ Datei-Markierungen: Einzelne Dateien zeigen Übersetzungsstatus');
        console.log('• 📈 Fortschritts-Prozentsätze: Detaillierte Statistiken pro Ordner');
        console.log('• 🎯 Smart-Sortierung: Übersetzte Dateien werden gruppiert angezeigt');
        console.log('• 📋 Projekt-Integration: Zeigt in welchen Projekten Dateien übersetzt sind');
        console.log('✅ ERWEITERTE FEATURES:');
        console.log('• 🔍 Erweiterte Suche: Ähnlichkeitssuche mit Normalisierung (ignoriert Groß-/Kleinschreibung, Punkte, Kommas)');
        console.log('• ⌨️ Keyboard-Navigation: Tab/Shift+Tab zwischen Textfeldern, Pfeiltasten für Zeilen, Leertaste für Audio');
        console.log('• 🖱️ Context-Menu: Rechtsklick für Audio, Text kopieren/einfügen, Ordner öffnen, Löschen');
        console.log('• 📋 Copy-Buttons: Direkte Kopierfunktion neben Textfeldern mit visuellem Feedback');
        console.log('• 📊 Fortschritts-Tracking: Completion-Status pro Datei, Statistiken pro Ordner');
        console.log('• 📋 Spalten-Sortierung: Nach Position, Name, Ordner, Completion - behält Export-Reihenfolge');
        console.log('• 📥 Erweiterte Import-Funktion: Intelligente Spalten-Erkennung mit Datenbank-Vergleich');
        console.log('✅ BESTEHENDE FEATURES:');
        console.log('• 🗂️ Projektverwaltung mit Auto-Save, Icons und Farben');
        console.log('• 🎨 Projekt & Ordner-Anpassung: Icons und Farben');
        console.log('• 📝 Drag & Drop Sortierung für Projekte und Dateien');
        console.log('• 🔢 Zeilennummer-Anpassung: Doppelklick auf # um Position zu ändern');
        console.log('• 📁 Intelligenter Ordner-Scan: Erkennt Struktur auf allen Ebenen');
        console.log('• 🧠 Smart Folder Detection: Findet Charaktere/Ordner automatisch');
        console.log('• 🔄 Universelles Auto-Scan für ALLE Funktionen');
        console.log('• ⚡ Intelligente Berechtigung-Erkennung mit sofortigem Scan');
        console.log('• 📏 Auto-Height Textboxen - EN/DE gleich breit, Höhe synchronisiert');
        console.log('• 📐 Responsive Spaltenbreite für alle Fenstergrößen');
        console.log('• ▶ Audio-Wiedergabe mit Auto-Scan direkt im Browser');
        console.log('• 📦 ZIP-Export mit Auto-Scan für echte Audio-Dateien');
        console.log('• 💾 Backup/Restore mit Projekt-Migration');
        console.log('• 🛠️ Debug-Tools für Datenquellen-Analyse');
        console.log('• 🎯 Highlighting von Suchbegriffen');
        console.log('🚀 REVOLUTIONÄR: Projekt-übergreifende Verfolgung des Übersetzungsfortschritts mit visuellen Indikatoren!');
    </script>
</body>
</html>

